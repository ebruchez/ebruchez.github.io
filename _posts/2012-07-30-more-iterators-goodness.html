---
layout: post
title: More iterators goodness
date: '2012-07-30T11:49:00.000-07:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-11-12T09:36:36.860-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-3609386509598405865
blogger_orig_url: https://blog.bruchez.name/2012/07/more-iterators-goodness.html
---

<p>Following-up on <a href="http://ebruchez.blogspot.com/2012/07/scala-iterators-and-iteratoriterate.html">the previous post about iterators</a>, say we have a clean Scala API with <code>Option</code> instead:</p> <pre><code class="scala">class Foo { def parent: Option[Foo] =  … }<br />def findBar(foo: Foo) = Option[Bar] = …</code></pre> <p>It turns out that <code>Iterator.iterate</code> falls apart with <code>Option</code>, because it requires a function returning a plain <code>T</code>. But we can write a better <code>Option</code>-aware <code>iterate</code> function:</p> <pre><code class="scala">def iterate[T](start: T)(f: T ⇒ Option[T]): Iterator[T] = new Iterator[T] {<br />  private[this] var acc = Option(start)<br />  def hasNext = acc.isDefined<br />  def next() = {<br />    val result = acc.get<br />    acc = f(result)<br />    result<br />  }<br />}</code></pre> <p>Note that this <code>iterate</code> does not depend at all on application-specific code. In fact, it could be part of the standard Scala library!</p> <p>With this new tool, the new <code>ancestorOrSelf</code> iterator simply looks like this:</p> <pre><code class="scala">def ancestorOrSelf(foo: Foo) =<br />  iterate(foo)(_.parent)</code></pre> <p>And one way to write <code>findInAncestorOrSelf</code> becomes:</p> <pre><code class="scala">def findInAncestorOrSelf(foo: Foo) =<br />  ancestorOrSelf(foo) map findBar find (_.isDefined) flatten</code></pre> <p>Now to be honest this last function is not fully satisfying, with its use of <code>isDefined</code> and its hanging <code>flatten</code> in the end! There are other ways to write it, including with <code>collectFirst</code>, but still it&#8217;s not quite right.</p> <p>The root issue is that <code>Scala.Iterator</code> doesn&#8217;t have a <code>headOption</code> (or a <code>nextOption</code>) method. Until that&#8217;s the case we can write our own extension method like this:</p> <pre><code class="scala">class MyIteratorOps[T](i: Iterator[T]) { def nextOption = if (i.hasNext) Option(i.next) else None }<br />implicit def toIteratorOps[T](i: Iterator[T]) = new MyIteratorOps(i)</code></pre> <p>or, with Scala 2.10:</p> <pre><code class="scala">implicit class MyIteratorOps(i: Iterator[T]) {<br />  def nextOption = if (i.hasNext) Option(i.next) else None<br />}</code></pre> <p>Again, this is something which could be in the standard Scala library. With this the final code becomes the much cleaner:</p> <pre><code class="scala">def findInAncestorOrSelf(foo: Foo) =<br />  ancestorOrSelf(foo) flatMap findBar nextOption</code></pre> <p>In the end it&#8217;s probably a matter of taste, but I would almost bet that as a programmer familiar with Scala collections, you would find this function immediately comprehensible. That&#8217;s a huge win in addition to the increased modularity gained through the use of iterators.</p>