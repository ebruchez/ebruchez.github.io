---
layout: post
title: Scala iterators and Iterator.iterate
date: '2012-07-30T11:31:00.000-07:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-11-12T09:35:26.924-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-796060233046575503
blogger_orig_url: https://blog.bruchez.name/2012/07/scala-iterators-and-iteratoriterate.html
---

<p>There is a common programming pattern where you navigate a hierarchy in order to find an element satisfying a certain condition. I have written code like this in Java probably a million times:</p> <pre><code class="java">class Foo { public Foo getParent() { … } }<br />public Bar findBar(Foo foo) { … }<br /><br />Bar findInAncestorOrSelf(Foo foo) {<br />    Foo currentFoo = foo;<br />    while (currentFoo != null) {<br />        Bar possibleResult = findBar(currentFoo);<br />        if (possibleResult != null)<br />            return possibleResult;<br />        currentFoo = currentFoo.getParent();<br />    }<br />    return null;<br />}</code></pre> <p>It is probably efficient but it&#8217;s not easy to read, it screams &#8220;boilerplate&#8221;, and it mixes two concerns:</p> <ul><li>navigating the hierarchy</li><li>doing something with elements in the hierarchy</li></ul> <p>So while you can write in the same style in Scala, there is a better way which starts with <em>iterators</em>. You probably know about the Java <code>Iterator</code> interface, which allows you to iterate over collections and also underlies the &#8220;for-each&#8221; construct. Scala also has an <code>Iterator</code> trait, which looks a lot like Java&#8217;s construct but supports <a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html#scala.collection.Iterator">lots of useful functions</a>. In fact it supports most of the functions found in <code>Traversable</code> (which is the base trait of every Scala collection).</p> <p>This makes Scala iterators immensely more useful than Java&#8217;s: implementing an iterator takes a few lines of code and instantly you have access to dozens of functions including <code>foreach</code>, <code>find</code>, <code>map</code>, <code>filter</code>, <code>++</code>.</p> <p>So what if you use an iterator to implement <code>findInAncestorOrSelf</code> above? You can implement your own iterator, but it just happens that here the built-in <code>Iterator.iterate</code> helps us bit: this function takes a starting object and a function to obtain the next object, and returns an iterator. Here is one which navigates all ancestors forever:</p> <pre><code class="scala">def ancestorOrSelf(foo: Foo) =<br />  Iterator.iterate(foo)(_.getParent)</code></pre> <p>And here is one which actually stops when there are no more ancestors:</p> <pre><code class="scala">def ancestorOrSelf(foo: Foo) =<br />  Iterator.iterate(foo)(_.getParent) takeWhile (_ ne null)</code></pre> <p>You can use that iterator to achieve the same as the original Java code (except it returns an <code>Option[Bar]</code>):</p> <pre><code class="scala">def findInAncestorOrSelf(foo: Foo) =<br />  ancestorOrSelf(foo) map findBar find (_ ne null)</code></pre> <p>It&#8217;s short and to the point, and the great thing is that you can use the iterator to do any kind of search or transformation of elements in the hierarchy: navigation is completely independent from the rest.</p> <p>See also <a href="http://ebruchez.blogspot.com/2012/07/more-iterators-goodness.html">More iterators goodness</a>.</p>