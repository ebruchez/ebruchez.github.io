---
layout: post
title: Scala array comparison (without a PhD)
date: '2013-05-21T20:25:00.000-07:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-11-14T20:05:54.009-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-4891872039623797798
blogger_orig_url: https://blog.bruchez.name/2013/05/scala-array-comparison-without-phd.html
---

<h3 id="scalacollectionsandequality">Scala collections and equality</h3> <p>Scala collections follow a simple set of general equality rules<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a>. Two collections are equal if:</p> <ul><li>they are in the same overall category (<code>Seq</code>, <code>Set</code>, or <code>Map</code>)</li><li>they contain the same elements (as defined by <code>==</code>)</li><li>for sequences, the elements are in the same order</li></ul> <p>This means the following:</p> <pre><code class="scala">scala&gt; List(1, 2, 3) == Vector(1, 2, 3)<br />res0: Boolean = true<br /><br />scala&gt; List(1, 2, 3) == Set(1, 2, 3)<br />res1: Boolean = false<br /><br />scala&gt; Set(1, 2, 3) == collection.mutable.LinkedHashSet(3, 1, 2)<br />res2: Boolean = true</code></pre> <h3 id="arraysdontbehave">Arrays don&#8217;t behave</h3> <p>The gotcha is that these rules break down with arrays:</p> <pre><code class="scala">scala&gt; List(1, 2, 3) == Array(1, 2, 3)<br />res3: Boolean = false</code></pre> <p>And even:</p> <pre><code class="scala">scala&gt; Array(1, 2, 3) == Array(1, 2, 3)<br />res4: Boolean = false</code></pre> <p>Why is this? The answer is that arrays in Java are treated specially all the way down to the JVM, and Scala arrays are just plain Java arrays. It is not possible to extend a JVM array, and this means in particular that it is not possible to override <code>equals</code> on arrays. Since native array eqality via <code>equals</code> does <em>not</em> compare array content, arrays are left to behave differently from Scala collections.</p> <h3 id="solutions">Solutions</h3> <p>So how do you go about comparing arrays in a way compatible with other Scala collections? First, there is an implicit conversion from <code>Array</code> to <code>collection.mutable.WrappedArray</code>, which is a <code>Seq</code>, so you can write:</p> <pre><code class="scala">scala&gt; (Array(1, 2, 3): WrappedArray[Int]) == (Array(1, 2, 3): WrappedArray[Int])<br />res5: Boolean = true</code></pre> <p>Or even shorter:</p> <pre><code class="scala">scala&gt; (Array(1, 2, 3): Seq[Int]) == (Array(1, 2, 3): Seq[Int])<br />res6: Boolean = true</code></pre> <p>Of course this also works if you pass an array to anything which expects a <code>Seq</code>:</p> <pre><code class="scala">scala&gt; def sameStuff(s1: Seq[Int], s2: Seq[Int]) = s1 == s2<br />foo: (s1: Seq[Int], s2: Seq[Int])Boolean<br /><br />scala&gt; sameStuff(Array(1, 2, 3), Array(1, 2, 3))<br />res7: Boolean = true</code></pre> <p>From a memory perspective, this is not too bad because <code>WrappedArray</code> doesn&#8217;t make an expensive copy of the collection and instead just wraps the array.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a> But there is <em>boxing</em> going on with <code>WrappedArray</code> because it&#8217;s not a <em>value class</em> <a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a> (or rather concrete implementations of it are not value classes). Value classes cannot override equality<a href="#fn:4" id="fnref:4" title="see footnote" class="footnote">[4]</a>, and a <code>WrappedArray</code> couldn&#8217;t be a proper <code>Seq</code> if that were the case.<a href="#fn:5" id="fnref:5" title="see footnote" class="footnote">[5]</a></p> <p>There is another way to compare array content with <code>sameElements</code>:</p> <pre><code class="scala">scala&gt; Array(1, 2, 3) sameElements Array(1, 2, 3)<br />res8: Boolean = true</code></pre> <p>The benefit is that this more explicitly states the intent, and you don&#8217;t need to convert the arrays to <code>Seq</code> via type declarations.</p> <h3 id="nestedarrays">Nested arrays</h3> <p>Both solutions above only work if arrays are not nested. Consider:</p> <pre><code class="scala">scala&gt; Array(Array(11), Array(21, 22)) sameElements Array(Array(11), Array(21, 22))<br />res9: Boolean = false</code></pre> <p>The reason is that <code>sameElements</code> (or <code>==</code> on <code>WrappedArray</code>) just calls <code>==</code> on each array element. If those elements are arrays, Java array equality kicks in again (and we know that array content is not compared in that case).</p> <p>Instead you can use the <code>deep</code> method:</p> <pre><code class="scala">scala&gt; Array(Array(11), Array(21, 22)).deep == Array(Array(11), Array(21, 22)).deep<br />res10: Boolean = true</code></pre> <p>The <code>deep</code> method wraps arrays so that each access to an array element is first checked: if the element itself is an array, it is wrapped with <code>WrappedArray</code> first.<a href="#fn:6" id="fnref:6" title="see footnote" class="footnote">[6]</a> This way equality recursively works (but only if each array is <em>directly</em> nested in an array!).</p> <p>It is generally safe to use <code>deep</code> instead of <code>sameElements</code> or a conversion to <code>WrappedArray</code>, but the implementation of <code>deep</code> requires a number of pattern matches, which are not known to be the fastest. If the arrays are known to be flat, the other approaches might be more efficient.</p> <h3 id="caseclasses">Case classes</h3> <p>Consider this case class:</p> <pre><code class="scala">scala&gt; case class Foo(a: Array[Int])<br />defined class Foo<br /><br />scala&gt; Foo(Array(1)) == Foo(Array(1))<br />res11: Boolean = false</code></pre> <p>By now you know why this happens: the case class provides an implementation of <code>==</code> for you, but doesn&#8217;t treat arrays specially. If equality matters to you (and it probably should if you use case classes), it is better to write instead something like this:</p> <pre><code class="scala">scala&gt; case class Foo(a: Seq[Int])<br />defined class Foo<br /><br />scala&gt; Foo(Array(1)) == Foo(Array(1))<br />res12: Boolean = true</code></pre> <p>Here the case class actually refers to a <code>WrappedArray</code>, obtained via implicit conversion from the original array.</p> <h3 id="wordsofwisdom">Words of wisdom</h3> <p>The equality issue suggests that it is wise to avoid arrays when possible. If you cannot avoid them, beware of the semantic of equality on them! But since arrays offer interoperability with Java and are compact, native data structures that offers performance benefits, it&#8217;s often hard to live without them entirely.</p> <p>There are a number of StackOverflow questions that cover this topic as well.<a href="#fn:7" id="fnref:7" title="see footnote" class="footnote">[7]</a> Please let me know if I omitted anything important!</p> <div class="footnotes"><hr /><ol> <li id="fn:1"><p>See <a href="http://www.scala-lang.org/docu/files/collections-api/collections_0.html">The Scala 2.8 Collections API - Equality</a> for details. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:2"><p>For an <code>Array[Int]</code>, the Scala implementation looks like: <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p> <pre><code class="scala">final class ofInt(val array: Array[Int]) extends WrappedArray[Int] { ... }</code></pre> <p>On the other hand it doesn&#8217;t seem like <code>WrappedArray</code> uses <code>java.util.Arrays.equals()</code> so the actual comparison performance might not be absolutely optimal (but I don&#8217;t have numbers).</p></li> <li id="fn:3"><p>Value classes are new in Scala 2.10. <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:4"><p><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">&#8220;A value classâ€¦ may not define a equals or hashCode method&#8221;</a> <a href="#fnref:4" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:5"><p>On the other hand <code>ArrayOps</code> are value classes: <a href="#fnref:5" title="return to article" class="reversefootnote">&#160;&#8617;</a></p> <pre><code class="scala">trait ArrayOps[T] extends Any with ...</code></pre> <p>This is ok because the purpose of <code>ArrayOps</code> is to provide extension methods on native arrays, and equality cannot be implemented as an extension method:</p> <pre><code class="scala">scala&gt; (Array(1, 2, 3): ArrayOps[Int]) == (Array(1, 2, 3): ArrayOps[Int])<br />res12: Boolean = false</code></pre></li> <li id="fn:6"><p>I find <code>deep</code> a bit funny: it returns an <code>IndexedSeq[Any]</code> instead of being generic. I am not sure why that is, but for the purpose of comparing array content it doesn&#8217;t matter. <a href="#fnref:6" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:7"><p>See: <a href="#fnref:7" title="return to article" class="reversefootnote">&#160;&#8617;</a></p> <ul><li><a href="http://stackoverflow.com/questions/5393243/how-do-i-compare-two-arrays-in-scala">How do I compare two arrays in scala?</a></li><li><a href="http://stackoverflow.com/questions/2481149/why-does-array0-1-2-array0-1-2-not-return-the-expected-result">Why does <code>Array(0,1,2) == Array(0,1,2)</code> not return the expected result?</a></li><li><a href="http://stackoverflow.com/questions/3737711/why-doesnt-the-array-equality-function-work-as-expected">Why doesn&#8217;t the Array Equality Function Work as Expected?</a></li></ul></li> </ol></div>