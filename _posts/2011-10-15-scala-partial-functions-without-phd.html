---
layout: post
title: Scala partial functions (without a PhD)
date: '2011-10-15T12:54:00.000-07:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2017-01-17T22:18:43.354-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-3036986710428869478
blogger_orig_url: https://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html
---

<p>If you have done some Scala for a while, you know about pattern matching and <code>match/case</code>. Things like:</p> <pre><code class="scala">value match {<br />  case Some(value) ⇒ …<br />  case None ⇒ …<br />}</code></pre> <p>But there is another use of the <code>case</code> keyword, without <code>match</code>, as in:</p> <pre><code class="scala">map foreach { case (k, v) ⇒ println(k + &quot; → &quot; + v) }</code></pre> <p>The first time I saw this kind of things I was a bit puzzled: in which situations could <code>case</code> be used without <code>match</code>? Well, it turns out <a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a> that a block with a bunch of <code>case</code> inside is one way of defining an <em>anonymous function</em>.</p> <p>There is nothing new with anonymous functions of course, and Scala has a very compact notation for those that doesn&#8217;t involve <code>case</code>. But this particular way of defining anonymous functions gives you a lot for free, namely all the good things of pattern matching like casting-done-right, guards, and destructuring. The example above, with <code>foreach</code>, shows how case can be used for destructuring the tuples of the map into key and value components.</p> <p>But there is more. Consider:</p> <pre><code class="scala">scala&gt; List(41, &quot;cat&quot;) map { case i: Int ⇒ i + 1 }<br />scala.MatchError: cat (of class java.lang.String)</code></pre> <p>As expected this crashes, because the pattern match doesn&#8217;t know what to do when the string &#8220;cat&#8221; is passed to it.</p> <p>On the other hand, this example doesn&#8217;t crash:</p> <pre><code class="scala">scala&gt; List(41, &quot;cat&quot;) collect { case i: Int ⇒ i + 1 }<br />res1: List[Int] = List(42)</code></pre> <p>So what&#8217;s the difference? Does <code>collect</code> just catch the <code>MatchError</code> and proceed? That would be clumsy and inefficient. In fact, the apparent magic lies in the fact that <code>case</code> blocks define special functions called <em>partial functions</em>. <a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a></p> <p>Now you might wonder, coming from a &#8220;normal&#8221; programming language background, what it means, for a function to be &#8220;partial&#8221;. Well, it <a href="http://en.wikipedia.org/wiki/Partial_function">comes from mathematics</a>, where it&#8217;s opposed to &#8220;total&#8221; functions.</p> <p>But even though it comes from math it&#8217;s actually simple. Take for example this function:</p> <pre><code class="scala">def inc(i: Int) = i + 1</code></pre> <p>It is <em>defined</em> for any <code>Int</code> input value. That means for that any <code>Int</code> argument, it produces a resulting <code>Int</code> result. <a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a></p> <p>A partial function on the other hand is defined only for a <em>subset</em> of the possible values of its arguments:</p> <pre><code class="scala">def fraction(d: Int) = 42 / d</code></pre> <p>is not defined for <code>d == 0</code> and <code>fraction(0)</code> will throw an exception. Think also of the square root function, which is not defined for negative real numbers. Examples abound. And it&#8217;s true also for the <code>collect</code> example above, where the anonymous function is only defined for an <code>Int</code> argument but not for a <code>String</code> (or any other) argument.</p> <p>So you get the idea about some values not &#8220;making sense&#8221; as the argument of a function because they can&#8217;t yield a significant result.</p> <p>Now if you think about it you will notice lots of situations like this in your programs, where functions are expected to work properly only for some input values. If the function is called with a disallowed value, it will typically crash, yield a special return value, or throw an exception (and this should better be documented). In short, partial function are very common in real-life programs even if you don&#8217;t know about it.</p> <p>So here <code>fraction</code> is defined as a regular function, but conceptually it is a partial function. The good thing is that Scala has built-in support for partial functions thanks to the <code>PartialFunction</code> trait. And here is one way of defining such a partial function:</p> <pre><code class="scala">val fraction = new PartialFunction[Int, Int] {<br />  def apply(d: Int) = 42 / d<br />  def isDefinedAt(d: Int) = d != 0<br />}</code></pre> <p>A <code>PartialFunction</code> must provides a method <code>isDefinedAt</code>, which allows the caller of the partial function to know, beforehand, whether the function can return a result for a given input value:</p> <pre><code class="scala">scala&gt; fraction.isDefinedAt(42)<br />res2: Boolean = true<br />scala&gt; fraction.isDefinedAt(0)<br />res3: Boolean = false</code></pre> <p>And if you call the function:</p> <pre><code class="scala">scala&gt; fraction(42)<br />res4: Int = 1<br />scala&gt; fraction(0)<br />java.lang.ArithmeticException: / by zero</code></pre> <p>This takes us back to the use of <code>case</code> to define partial functions. The exact same function can be written:</p> <pre><code class="scala">val fraction: PartialFunction[Int, Int] =<br />  { case d: Int if d != 0 ⇒ 42 / d }</code></pre> <p>(Notice that you must specify that the <code>PartialFunction[Int, Int]</code> type. It would be great if Scala had a syntax to make this even more compact but it doesn&#8217;t as of Scala 2.11.)</p> <p>And if you call the function:</p> <pre><code class="scala">scala&gt; fraction(42)<br />res5: Int = 1<br />scala&gt; fraction(0)<br />scala.MatchError: 0 (of class java.lang.Integer)</code></pre> <p>(Note that there is one visible difference from the outside when you use the case way: you get a <code>MatchError</code> as you usually do with pattern matching.)</p> <p>The idea doesn&#8217;t apply only to numbers. In our <code>collect</code> example above, the partial function implicitly defined looks like this:</p> <pre><code class="scala">val incAny: PartialFunction[Any, Int] =<br />  { case i: Int ⇒ i + 1 }</code></pre> <p>The function takes an <code>Any</code> as parameter because <code>List(41, &quot;cat&quot;)</code> is a <code>List[Any]</code>. But it is only defined for inputs that are of type <code>Int</code>:</p> <pre><code class="scala">scala&gt; incAny(41)<br />res6: Int = 42<br />scala&gt; incAny(&quot;cat&quot;)<br />scala.MatchError: cat (of class java.lang.String)</code></pre> <p>Passing a <code>String</code> didn&#8217;t go too well, as expected. But now you can check this before calling the function with:</p> <pre><code class="scala">scala&gt; incAny.isDefinedAt(41)<br />res7: Boolean = true<br />scala&gt; incAny.isDefinedAt(&quot;cat&quot;)<br />res8: Boolean = false</code></pre> <p>So we now have the explanation for the difference in behavior between <code>collect</code> and <code>map</code>, which is that <code>collect</code> expects a partial function. It asks <code>incAny</code> whether it is defined for <code>41</code> and then <code>&quot;cat&quot;</code>, and so automatically filters out <code>&quot;cat&quot;</code>. Another cool thing here is that the Scala compiler can even infer a clean resulting collection type: <code>List[Int]</code>!</p> <pre><code class="scala">scala&gt; List(41, &quot;cat&quot;) collect incAny<br />res9: List[Int] = List(42)</code></pre> <p>Also, as you notice, if you define the partial function inline, the compiler knows that it&#8217;s a partial function and you avoid the explicit <code>PartialFunction</code> trait.</p> <p>Notice that partial functions can lie:</p> <pre><code class="scala">scala&gt; val liar: PartialFunction[Any, Int] =<br />  { case i: Int ⇒ i; case s: String ⇒ s.toInt }<br />liar: PartialFunction[Any,Int] = &lt;function1&gt;<br />scala&gt; liar.isDefinedAt(42)<br />res10: Boolean = true<br />scala&gt; liar.isDefinedAt(&quot;cat&quot;)<br />res11: Boolean = true<br />scala&gt; liar(&quot;cat&quot;)<br />java.lang.NumberFormatException: For input string: &quot;cat&quot;</code></pre> <p>Here <code>liar</code> says incorrectly that it&#8217;s defined for <code>&quot;cat&quot;</code>. It would probably be better to write:</p> <pre><code class="scala">scala&gt; val honest: PartialFunction[Any, Int] =<br />  { case i: Int ⇒ i; case s: String if isParsableAsInt(s) ⇒ s.toInt }<br />honest: PartialFunction[Any,Int] = &lt;function1&gt;<br />scala&gt; honest.isDefinedAt(&quot;cat&quot;)<br />res12: Boolean = false</code></pre> <p>So now you see how partial functions defined with <code>case</code> can be used for things like <code>collect</code> with a super compact notation. You will see them in other places, including catch expressions.</p> <p>There is another situation in Scala where partial functions are &#8220;just there&#8221; and you might not know it. Take the following List:</p> <pre><code class="scala">val pets = List(&quot;cat&quot;, &quot;dog&quot;, &quot;frog&quot;)</code></pre> <p>In Scala, any instance of <code>Seq</code>, <code>Set</code> or <code>Map</code> is also a function. So you can write:</p> <pre><code class="scala">scala&gt; pets(0)<br />res13: java.lang.String = cat</code></pre> <p>But:</p> <pre><code class="scala">scala&gt; pets(3)<br />java.lang.IndexOutOfBoundsException: 3</code></pre> <p>Wouldn&#8217;t that mean that the <code>pets</code> function is, hum, only <em>defined</em> for values <code>0</code>, <code>1</code>, and <code>2</code>? Sounds familiar? Wouldn&#8217;t it be cool to look at pets as a partial function then? Well you can because in Scala any instance of <code>Seq</code> or <code>Map</code> (but not <code>Set</code>) is actually a partial function. So you can write:</p> <pre><code class="scala">scala&gt; pets.isDefinedAt(0)<br />res14: Boolean = true<br />scala&gt; pets.isDefinedAt(3)<br />res15: Boolean = false</code></pre> <p>And if you had a list of indexes and wanted to safely collect values for these indexes in a new list, you could write:</p> <pre><code class="scala">scala&gt; Seq(1, 2, 42) collect pets<br />res16: Seq[java.lang.String] = List(dog, frog)</code></pre> <p>Here it works well because <code>collect</code> handles everything for us. But it can be a pain to check <code>isDefinedAt</code> all over the place. If anything, it feels a bit like a <code>null</code> check, and we hate those in Scala. The good news is that in Scala the <code>PartialFunction</code> trait supports the <code>lift</code> method, which converts the partial function to a normal function that doesn&#8217;t crash:</p> <pre><code class="scala">scala&gt; pets.lift(0)<br />res17: Option[java.lang.String] = Some(cat)<br />scala&gt; pets.lift(42)<br />res18: Option[java.lang.String] = None</code></pre> <p>As you see the <code>lift</code> returns a function that returns an <code>Option</code> of the value. This allows you to safely process values without <code>null</code> checks and without calling <code>isDefinedAt</code> yourself:</p> <pre><code class="scala">scala&gt; pets.lift(0) map (&quot;I love my &quot; + _) getOrElse &quot;&quot;<br />res19: java.lang.String = I love my cat<br />scala&gt; pets.lift(42) map (&quot;I love my &quot; + _) getOrElse &quot;&quot;<br />res20: java.lang.String = &quot;&quot;</code></pre> <p>I hope this helps make some sense of partial functions in Scala.</p> <p><em>NOTE: This post was updated on 2014&#8211;12&#8211;27 to fix the use of <code>def</code> where <code>val</code> was called for, based on user comments. A few typos have been corrected as well.</em></p> <p><em>NOTE: This post was updated on 2017&#8211;01&#8211;17 to address the fact that <code>Set</code> is not a partial function, as kindly noted by a reader.</em></p> <div class="footnotes"><hr /><ol> <li id="fn:1"><p>From The Scala Language Specification: &#8220;An anonymous function can be defined by a sequence of cases […] which appear as an expression without a prior match.&#8221; <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:2"><p>This is not to be confused with <em>partially applied functions</em>, which are a completely different topic. <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:3"><p>In Scala, it is defined even for <code>Int.MaxValue</code>, as <code>Int.MaxValue + 1 == Int.MinValue</code>. The result is just plain wrong but it&#8217;s defined! <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> </ol></div>