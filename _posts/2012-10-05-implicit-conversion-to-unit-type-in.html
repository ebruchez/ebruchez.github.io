---
layout: post
title: Implicit conversion to the Unit type in Scala
date: '2012-10-05T10:02:00.000-07:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-11-14T11:34:05.808-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-2619114618400983867
blogger_orig_url: https://blog.bruchez.name/2012/10/implicit-conversion-to-unit-type-in.html
---

<p>In Scala, you have a few ways to express that a function returns the <code>Unit</code> type.<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a> A common way is to use the function syntax and specify a result type of <code>Unit</code>:</p> <pre><code class="scala">def foo: Unit = ...</code></pre> <p>Like for any result type, the type annotation is not necessary if the function body already returns the expected type, as in:</p> <pre><code class="scala">def newline = println()</code></pre> <p>or:<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a></p> <pre><code class="scala">trait Foo {<br />  def log = ()<br />}</code></pre> <p>The type annotation is useful not only for documentation purposes, but also in case the last expression of the function body happens to return a result of a type which is not <code>Unit</code>:</p> <pre><code class="scala">def focus(): Boolean = ...    // function with side effect but which also returns a value<br />def justFocus: Unit = focus() // function with side effect returning Unit</code></pre> <p>Now you might wonder, as <a href="https://twitter.com/avernet">@avernet</a> and I did yesterday, how this last bit can work! How does the compiler, with an expected type of <code>Unit</code> on one hand, and an actual expression type of <code>Boolean</code> on the other hand, reconcile the two?</p> <p>This is not done via subtyping, because <code>Unit</code> is not a supertype of <code>Boolean</code>: instead <code>Unit</code> is a subtype of <code>AnyVal</code>and at the same level as <code>Boolean</code> in the <a href="http://www.scala-lang.org/node/128">Scala type hierarchy</a>.</p> <p>The answer is that there is an <em>implicit conversion</em> taking place.<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a> The <a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">Scala language specification</a> specifies this conversion in section 6.26.1:</p> <blockquote><p><em>Value Discarding</em>. If <em>e</em> has some value type and the expected type is <code>Unit</code>, <em>e</em> is converted to the expected type by embedding it in the term <code>{ e; () }</code>.</p></blockquote> <p>In case you are wondering, here <em>value type</em> does <em>not</em> mean a subtype of <code>AnyVal</code>. This can be a bit misleading, especially with the introduction in Scala 2.10 of <em>value classes</em>, which <em>do</em> derive from <code>AnyVal</code>. Instead, a value type is just a type which can have concrete values, as explained in chapter 3 of the spec:</p> <blockquote><p>A subset of first-order types called <em>value types</em> represents sets of (first-class) values. […] Non-value types capture properties of identifiers that are not values (§3.3). For example, a type constructor (§3.3.3) does not directly specify a type of values.&quot;</p></blockquote> <p>In short the spec mandates that any value returned by an expression is implicitly converted to <code>Unit</code> by the compiler when the expected type is <code>Unit</code>. This applies in particular to functions, where the expression is the function body and the expected type is determined with the <code>Unit</code> type annotation.</p> <p>So now we all know how it works!</p> <div class="footnotes"><hr /><ol> <li id="fn:1"><p><code>Unit</code> is similar to the <code>void</code> of C or Java, but a bit fancier. For example you can have variables of type <code>Unit</code>, and pass a value of type <code>Unit</code> around) <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:2"><p>Note the syntax for the <code>Unit</code> value: <code>()</code>. <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:3"><p>This doesn&#8217;t mean that the implicit conversion is actually defined in the <code>Predef</code> object with the <code>implicit</code>keyword. It could possibly be implemented that way, but as of Scala 2.10 this is not the case. So it&#8217;s probably done by compiler magic. <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> </ol></div>