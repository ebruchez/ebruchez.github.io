---
layout: post
title: Generalized type constraints in Scala (without a PhD)
date: '2015-11-17T09:47:00.000-08:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-12-10T15:10:23.147-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-3883264081183389253
blogger_orig_url: https://blog.bruchez.name/2015/11/generalized-type-constraints-in-scala.html
---

<h3 id="introduction">Introduction</h3> <p>Not long ago I stumbled upon the signature of the <code>flatten</code> method on <code>Option</code>:</p> <pre><code class="scala">def flatten[B](implicit ev: A &lt;:&lt; Option[B]): Option[B]</code></pre> <p>I don&#8217;t know about you, but I knew about implicit parameter lists, implicit resolution, and even type bounds. But this funny <code>&lt;:&lt;</code> &#8220;sad-with-a-hat&#8221; <a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a> operator <a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a> was entirely new to me!</p> <p>Smart people <a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a> have written about it years ago, but it&#8217;s clear that we are talking about a feature which is not well-known and poorly documented, even though it is available since Scala 2.8. So this article is about figuring out what it means and how it works.</p> <p>The following deconstruction turns out to be fairly long, but even though <code>&lt;:&lt;</code> itself may not be useful to every Scala programmer, it touches a surprisingly large number of Scala features which most Scala programmers should know.</p> <h3 id="whatitdoesandhowitsuseful">What it does and how it&#8217;s useful</h3> <p>If you search the Scala standard library, you find a few other occurrences of <code>&lt;:&lt;</code>, in particular:</p> <ul><li><p>on <code>Option</code>:</p> <pre><code class="scala">def orNull[A1 &gt;: A](implicit ev: Null &lt;:&lt; A1): A1</code></pre></li><li><p>on <code>Traversable</code> (via traits like <code>GenTraversableOnce</code>):</p> <pre><code class="scala">def toMap[K, V](implicit ev: A &lt;:&lt; (K, V)): Map[K, V]</code></pre></li><li><p>on <code>Either</code>:</p> <pre><code class="scala">def joinRight[A1 &gt;: A, B1 &gt;: B, C](implicit ev: B1 &lt;:&lt; Either[A1, C]): Either[A1, C]</code></pre></li><li><p>on <code>Try</code>:</p> <pre><code class="scala">def flatten[U](implicit ev: T &lt;:&lt; Try[U]): Try[U]</code></pre></li></ul> <p>You notice that, in all these examples, <code>&lt;:&lt;</code> is used in the same way:</p> <ul><li>there is an implicit parameter list, with a single parameter called <code>ev</code></li><li>the <em>type</em> of this parameter is of the form <code>Type1 &lt;:&lt; Type2</code></li></ul> <p>The lowdown is that this pattern tells the compiler:</p> <blockquote><p>Make sure that <code>Type1</code> is a <em>subtype</em> of <code>Type2</code>, or else report an error.</p></blockquote> <p>This is part of a feature called <em>generalized type constraints</em>. <a href="#fn:4" id="fnref:4" title="see footnote" class="footnote">[4]</a> There is another similar construct, <code>=:=</code>, which tells the compiler: <a href="#fn:5" id="fnref:5" title="see footnote" class="footnote">[5]</a></p> <blockquote><p>Make sure that <code>Type1</code> is <em>exactly the same</em> as <code>Type2</code>, or else report an error.</p></blockquote> <p>In what follows, I am focusing on <code>&lt;:&lt;</code> which turns out to be more useful, but just know that <code>=:=</code> is a thing and works in a very similar way.</p> <p>The <em>why</em> and <em>how</em> of this feature is the subject of the rest of this article! So for now, let&#8217;s take this as a recipe, a trick if you will, while we look at how this can be useful in practice.</p> <p>Let&#8217;s start with <code>flatten</code> on <code>Option</code>:</p> <pre><code class="scala">def flatten[B](implicit ev: A &lt;:&lt; Option[B]): Option[B]</code></pre> <p>What does <code>flatten</code> do, as per the documentation? It removes a level of nesting of options:</p> <pre><code class="scala">scala&gt; val oo: Option[Option[Int]] = Some(Some(42))<br />oo: Option[Option[Int]] = Some(Some(42))<br /><br />scala&gt; oo.flatten<br />res1: Option[Int] = Some(42)</code></pre> <p>This doesn&#8217;t make much sense if the type parameter <code>A</code> of <code>Option</code> is not, itself, an <code>Option</code>-of-something. So what should happen if you call <code>flatten</code> on, say, an <code>Option[String]</code>? I see two possibilities:</p> <ol><li>The <code>flatten</code> method returns <code>None</code>.</li><li>The compiler reports an error.</li></ol> <p>The authors of the Scala standard library picked option 2, and I think that it&#8217;s a good choice, because most likely calling <code>flatten</code> in this case is not what the programmer intends. And lo and behold, the compiler doesn&#8217;t let this pass:</p> <pre><code class="scala">scala&gt; val oi: Option[Int] = Some(42)<br />oi: Option[Int] = Some(42)<br /><br />scala&gt; oi.flatten<br />&lt;console&gt;:21: error: Cannot prove that Int &lt;:&lt; Option[B].<br />       oi.flatten</code></pre> <p>So we have a generic type, <code>Option[+A]</code>, which has a method, <code>flatten</code>, which can only be used if the type parameter <code>A</code> is itself an <code>Option</code>. All the other methods (except <code>orNull</code> which is similar to <code>flatten</code>) can be called: <code>map</code>, <code>get</code>, etc. But <code>flatten</code>? Only if the type of the option is right!</p> <p>One thing to realize is that we have something unusual here: a method which the compiler won&#8217;t let us call, not because we pass incorrect parameters to the method (in fact <code>flatten</code> doesn&#8217;t even take any explicit parameters), but based on the value of a <em>type parameter</em> of the underlying <code>Option</code> class. This is not something you see in Java, and you have probably rarely seen it in Scala.</p> <p>Looking again at the signature of <code>flatten</code>, we can see how the recipe is applied: <code>implicit ev: A &lt;:&lt; Option[B]</code> reads &#8220;make sure that <code>A</code> is a subtype of <code>Option[B]</code>&#8221;, and, since <code>A</code> stands for the parameter type of <code>Option</code>, we have:</p> <ul><li>in the first case &#8220;make sure that <code>Option[Int]</code> is a subtype of <code>Option[B]</code>&#8221;</li><li>in the second case &#8220;make sure that <code>Int</code> is a subtype of <code>Option[B]</code>&#8221;</li></ul> <p>Obviously, <code>Option[Int]</code> can be a subtype of an <code>Option[B]</code>, where <code>B = Int</code> (or <code>B = AnyVal</code>, or <code>B = Any</code>). On the flip side, there is just no way <code>Int</code> can be a subtype of <code>Option[B]</code>, whatever <code>B</code> might be. So the recipe works, and therefore the constraint works. <a href="#fn:6" id="fnref:6" title="see footnote" class="footnote">[6]</a></p> <p>To get the hang of it, let&#8217;s look at another nice use case , <code>toMap</code> on <code>Traversable</code>:</p> <pre><code class="scala">def toMap[K, V](implicit ev: A &lt;:&lt; (K, V)): Map[K, V]</code></pre> <p>Translated into English: you can convert a <code>Traversable</code> to a <code>Map</code> with <code>toMap</code>, but only if the element type is a tuple <code>(K, V)</code>. This makes sense, because a <code>Map</code> can be seen as a collection of key/value tuples. It wouldn&#8217;t make great sense to create a <code>Map</code> just out of a sequence of 5 <code>Int</code>s, for example.</p> <p>Similar rationales apply to the few other uses of <code>&lt;:&lt;</code> in the standard library, which all come down to constraining methods to work with a specific contained type only.</p> <p>In light of these examples, I find that applying this recipe is easy, even though the syntax is a bit funny. But I can think of a few questions:</p> <ol><li>Can&#8217;t we just use <em>type bounds</em> which I thought existed to enforce this kind of type constraints?</li><li>If this is a <em>pattern</em> rather than a built-in feature, why does <code>&lt;:&lt;</code>Â look so much like an operator? Does the compiler have special support for it?</li><li>How does this whole thing even work?</li><li>Is there an easier ways to achieve the same result?</li></ol> <p>Let&#8217;s look into each of these questions in order.</p> <h3 id="question1:cantwejustusetypebounds">Question 1: Can&#8217;t we just use type bounds?</h3> <h4 id="lowerandupperbounds">Lower and upper bounds</h4> <p><em>Type bounds</em> cover <em>lower bounds</em> and <em>upper bounds</em>. <a href="#fn:7" id="fnref:7" title="see footnote" class="footnote">[7]</a> These are well explained in the book <a href="http://www.artima.com/pins1ed/type-parameterization.html#19.5">Programming in Scala</a>, so I won&#8217;t cover the basics here, but I will present some perspective on how they work.</p> <p>As a reminder, lower and upper bounds are expressed with <em>builtin syntax</em>: <code>&gt;:</code> and <code>&lt;:</code> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#type-parameters">spec</a>). You can read:</p> <ul><li><code>T &gt;: U</code> as &#8220;type <code>T</code> is a supertype of type <code>U</code>&#8221; or &#8220;type <code>T</code> has type <code>U</code> as lower bound&#8221;</li><li><code>T &lt;: U</code> as &#8220;type <code>T</code> is a subtype of type <code>U</code>&#8221; or &#8220;type <code>T</code> has type <code>U</code> as upper bound&#8221;</li></ul> <h4 id="apuzzler">A puzzler</h4> <p>Let&#8217;s consider the following:</p> <pre><code class="scala">scala&gt; def tuple[T, U](t: T, u: U) = (t, u)<br />tuple: [T, U](t: T, u: U)(T, U)</code></pre> <p>My <code>tuple</code> function simply returns a tuple of the two values passed, whatever their types might be. Granted, it&#8217;s not very useful!</p> <p>What are <code>T</code> and <code>U</code>? They are type variables: they <em>stand for</em> actual types that will be decided at each call site (each use of the function in the source code). Here both <code>T</code> and <code>U</code> are <em>abstract</em>: we don&#8217;t know what they will be when we write the function. For example we don&#8217;t say that <code>U</code> is a <code>Banana</code>, which would be a <em>concrete</em> type.</p> <p>If we pass <code>String</code> and <code>Int</code> parameters, we get back a tuple <code>(String, Int)</code> in the Scala REPL:</p> <pre><code class="scala">scala&gt; tuple(&quot;Lincoln&quot;, 42)<br />res1: (String, Int) = (Lincoln,42)</code></pre> <p>Now let&#8217;s consider the following modification, which is a naive attempt at enforcing type constraints with type bounds:</p> <pre><code class="scala">def tupleIfSubtype[T &lt;: U, U](t: T, u: U) = (t, u)</code></pre> <p>I know, it&#8217;s starting to be like an alphabet (and symbol) soup! But let&#8217;s stay calm: the only change is that instead of specifying just <code>T</code> as type parameter, we specify <code>T &lt;: U</code>, which means &#8220;<code>T</code> must be a subtype of <code>U</code>&#8221;.</p> <p>The intent of <code>tupleIfSubtype</code> is to return a tuple of the two values passed, like <code>tuple</code> above, but fail at compile time if the first value is not a subtype of the second value.</p> <p>So does the newly added constraint work? Do you think that the compiler will accept to compile this?</p> <pre><code class="scala">tupleIfSubtype(&quot;Lincoln&quot;, 42)</code></pre> <p>Before knowing better, I would have thought that the compiler:</p> <ul><li>would decide that <code>T = String</code></li><li>would decide that <code>U = Int</code></li><li>see the type constraint <code>T &lt;: U</code>, which translates into <code>String &lt;: Int</code></li><li>fail compilation because obviously, <code>String</code> is not a subtype of <code>Int</code></li></ul> <p>But it turns out that this actually compiles just fine!</p> <p>How can this be? Is the constraint not considered? Is it a bug in the compiler? A weird edge case? Bad language design? Or maybe, with <code>T &lt;: U</code>, the <code>U</code> is not the same as the second <code>U</code> in the type parameter section? This can quickly be proven false:</p> <pre><code class="scala">scala&gt; def tupleIfSubtype[T &lt;: V, U](t: T, u: U) = (t, u)<br />&lt;console&gt;:7: error: not found: type V<br />       def tupleIfSubtype[T &lt;: V, U](t: T, u: U) = (t, u)</code></pre> <p>So the two <code>U</code>s are, as seemed to make sense intuitively, <em>bound</em> to each other (they refer to the same type).</p> <p>The answer to this puzzler turns out to be relatively simple: it has to do with the way type inference works, namely that type inference solves a <em>constraint system</em> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#local-type-inference">spec</a>).</p> <p>What happens is that yes, I do pass <code>String</code> and <code>Int</code>, but it doesn&#8217;t follow that <code>T = String</code> and <code>U = Int</code>. Instead, the effective <code>T</code> and <code>U</code> are the <em>result</em> of the compiler working its type inference algorithm, given:</p> <ul><li>the types of the parameters we actually pass to the function,</li><li>the constraints expressed in the type parameter section,</li><li>and, in some cases, the expression&#8217;s return type.</li></ul> <p>If I write:</p> <pre><code class="scala">scala&gt; def tuple[T, U](t: T, u: U) = (t, u)<br />tuple: [T, U](t: T, u: U)(T, U)<br /><br />scala&gt; tuple(&quot;Lincoln&quot;, 42)<br />res3: (String, Int) = (Lincoln,42)</code></pre> <p>then yes: <code>T = String</code> and <code>U = Int</code> because there are no other constraints. But when I introduce an upper bound, there <em>is</em> a constraint, and therefore a constraint system. The compiler resolves it and obtains <code>T = String</code> and <code>U = Any</code>:</p> <pre><code class="scala">scala&gt; def tupleIfSubtype[T &lt;: U, U](t: T, u: U) = (t, u)<br />tupleIfSubtype: [T &lt;: U, U](t: T, u: U)(T, U)<br /><br />scala&gt; tupleIfSubtype(&quot;Lincoln&quot;, 42)<br />res4: (String, Any) = (Lincoln,42)</code></pre> <p>We can verify that the resulting types satisfy the constraints: <a href="#fn:8" id="fnref:8" title="see footnote" class="footnote">[8]</a></p> <ul><li><code>String</code> is a <code>String</code> of course</li><li><code>Int</code> is a subtype of <code>Any</code></li><li><code>String</code> is also a subtype of <code>Any</code></li></ul> <p>Phew! So this makes sense. It&#8217;s &#8220;just&#8221; a matter of understanding how type inference works when type bounds are present.</p> <p>In the process we have learned that <code>&lt;:</code> and <code>&gt;:</code>, when used with abstract type parameters, do not necessarily produce results which are very useful, because the compiler can easily infer <code>Any</code> (or <code>AnyVal</code> or <code>AnyRef</code>) as solutions to the constraint system. <a href="#fn:9" id="fnref:9" title="see footnote" class="footnote">[9]</a></p> <h3 id="question2:whydoes:looksomuchlikeanoperator">Question 2: Why does &lt;:&lt;Â look so much like an operator?</h3> <p>Lets dig a little deeper to understand how <code>&lt;:&lt;</code> works under the hood. Here is a simple type hierarchy used in the examples below:</p> <pre><code class="scala">trait Fruit<br />class Apple  extends Fruit<br />class Banana extends Fruit</code></pre> <h4 id="parameterlistsandtypeinference">Parameter lists and type inference</h4> <p>Let&#8217;s start with a couple more things you need to know in Scala:</p> <ul><li>Functions can have more than one parameter list.</li><li>Type inference operates parameter list per parameter list from left to right.</li></ul> <p>In particular, an <em>implicit</em> parameter list can use types inferred in previous parameter lists.</p> <p>So let&#8217;s write the solution, without necessarily understanding it fully yet:</p> <pre><code class="scala">def tupleIfSubtype[T, U](t: T, u: U)(implicit ev: T &lt;:&lt; U) = (t, u)</code></pre> <p>This function has two parameter lists:</p> <ul><li><code>(t: T, u: U)</code></li><li><code>(implicit ev: T &lt;:&lt; U)</code></li></ul> <p>Because type inference goes parameter list by parameter list, let&#8217;s start with the first one. You notice that there are no <code>&gt;:</code> or <code>&lt;:</code> type bounds! So:</p> <ul><li><code>T</code> is whatever specific type <code>t</code> has (say <code>T = Banana</code>)</li><li><code>U</code> is whatever specific type <code>u</code> has (say <code>U = Fruit</code>)</li></ul> <h4 id="infixtypes">Infix types</h4> <p>Looking at the second parameter list, we have to clear a hurdle: what kind of syntax is <code>T &lt;:&lt; U</code>? This notation is called an <em>infix type</em> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#infix-types">spec</a>). &#8220;Infix&#8221; just means that a type appears <em>in the middle</em> of two other types, the same way the <code>+</code> operator appears in the middle in <code>2 + 2</code>. The type in the middle (the infix type proper) can be referred to a an <em>infix operator</em>. Instead of this operator being a method, as is the case in general in Scala, it is a <em>type</em>.</p> <p>Let&#8217;s look at examples. You probably know types from the standard library such as:</p> <pre><code class="scala">Map[String, Fruit]<br />Either[String, Boolean]</code></pre> <p>These exact same types can be written:</p> <pre><code class="scala">String Map Fruit<br />String Either Boolean</code></pre> <p>The infix notation makes the parametrized type look like an operator, but an operator on <em>types</em> instead of <em>values</em>. Other than that, it&#8217;s just an alternate syntax, and really nothing to worry about!</p> <p>So based on the above:</p> <pre><code class="scala">T &lt;:&lt; U</code></pre> <p>means the the same as:</p> <pre><code class="scala">&lt;:&lt;[T, U]</code></pre> <h4 id="asymbolictypename">A symbolic type name</h4> <p>Now, what is a <code>&lt;:&lt;</code>? It&#8217;s a type: the same kind of stuff as <code>Map</code> or <code>Either</code>, in other words, typically a class or a trait. It&#8217;s just that this is a symbolic name instead of an alphabetic identifier like <code>Map</code>. It could as well have been called <code>SubtypeOf</code>, and maybe it should have been!</p> <h4 id="theimplicitparameter">The implicit parameter</h4> <p>So once we reach the second (and implicit) parameter list:</p> <pre><code class="scala">(implicit ev: T &lt;:&lt; U)</code></pre> <p>we see that there is a parameter of type <code>&lt;:&lt;</code>, which itself has two type parameters, <code>T</code> and <code>U</code>. These are the <em>same</em> <code>T</code> and <code>U</code> we have in the first parameter list. They are <em>bound</em> to those, and these are known because type inference already did its magic on the first parameter list. Concretely, <code>T</code> is now assigned the type <code>Banana</code> and <code>U</code> the type <code>Fruit</code>!</p> <p>What the implicit parameter list says is this: &#8220;Find me, somewhere in the implicit search path, an implicit <code>val</code>, <code>def</code>, or <code>class</code> of type <code>&lt;:&lt;</code> which satisfies <code>&lt;:&lt;[T, U]</code>&#8221;. <a href="#fn:10" id="fnref:10" title="see footnote" class="footnote">[10]</a> And because <code>T</code> and <code>U</code> are now known, we need to find an implicit match for <code>&lt;:&lt;[Banana, Fruit]</code>.</p> <p>The trick is to manage to have an implicit definition in scope which matches <em>only</em> if there is a <em>subtype</em> relationship between <code>T</code> and <code>U</code>. For example:</p> <table><colgroup><col style="text-align:left;"/><col style="text-align:left;"/><col style="text-align:left;"/></colgroup> <thead><tr> <th style="text-align:left;">T</th> <th style="text-align:left;">U</th> <th style="text-align:left;">Compiler Happiness Level</th></tr></thead> <tbody><tr> <td style="text-align:left;"><code>Banana</code></td> <td style="text-align:left;"><code>Fruit</code></td> <td style="text-align:left;">happy</td></tr><tr> <td style="text-align:left;"><code>Apple</code></td> <td style="text-align:left;"><code>Fruit</code></td> <td style="text-align:left;">happy</td></tr><tr> <td style="text-align:left;"><code>Int</code></td> <td style="text-align:left;"><code>Anyval</code></td> <td style="text-align:left;">happy</td></tr><tr> <td style="text-align:left;"><code>Apple</code></td> <td style="text-align:left;"><code>Banana</code></td> <td style="text-align:left;">unhappy</td></tr><tr> <td style="text-align:left;"><code>String</code></td> <td style="text-align:left;"><code>Int</code></td> <td style="text-align:left;">unhappy</td></tr></tbody></table><p>If we manage to create such an implicit definition, the constraint mechanism works. And we already know that the clever engineers who devised this have found a way to create such an implicit definition!</p> <p>By the way, we can play with this in the REPL using the standard <code>implicitly</code> function, which returns an implicit value for the given type parameter if one is found:</p> <pre><code class="scala">implicitly[Banana &lt;:&lt; Fruit]  // ok<br />implicitly[Apple  &lt;:&lt; Fruit]  // ok<br />implicitly[Int    &lt;:&lt; Anyval] // ok<br />implicitly[Apple  &lt;:&lt; Banana] // not ok<br />implicitly[String &lt;:&lt; Int]    // not ok</code></pre> <p>To summarize, we now have a pretty good level of understanding and we know that:</p> <ul><li>we are talking about a library feature</li><li>which relies on an implicit parameter</li><li>with a funny symbolic type operator <code>&lt;:&lt;</code>.</li></ul> <p>And we also know that the magic that makes it all work lies in the search for a matching implicit definition: if it is found, the subtyping relationship holds, otherwise it doesn&#8217;t and the compiler reports and error.</p> <h3 id="question3:howdoesthiswholethingevenwork">Question 3: How does this whole thing even work?</h3> <p>We could stop here and be happy to use <code>&lt;:&lt;</code> like a recipe, as if it was a core language feature. But that wouldn&#8217;t be very satisfying, would it? After all, we still miss the <em>deeper</em> understanding of how that magic implicit is defined, and why an implicit search for it may or may not match it. So let&#8217;s keep going!</p> <h4 id="theimplementation">The implementation</h4> <p>Let&#8217;s look at the implementation of <code>&lt;:&lt;</code>, which we find in the Scala <code>Predef</code> object <a href="#fn:11" id="fnref:11" title="see footnote" class="footnote">[11]</a>:</p> <pre><code class="scala">@implicitNotFound(msg = &quot;Cannot prove that ${From} &lt;:&lt; ${To}.&quot;)<br />sealed abstract class &lt;:&lt;[-From, +To] extends (From â To) with Serializable<br /><br />private[this] final val singleton_&lt;:&lt; = new &lt;:&lt;[Any, Any] {<br />  def apply(x: Any): Any = x<br />}<br /><br />implicit def $conforms[A]: A &lt;:&lt; A = singleton_&lt;:&lt;.asInstanceOf[A &lt;:&lt; A]</code></pre> <p>Wow! Can we figure it out? Let&#8217;s try.</p> <h4 id="whichimplicit">Which implicit?</h4> <p>Let&#8217;s think about a simpler case of implicit search:</p> <pre><code class="scala">def makeMeASandwich(implicit logger: Logger) = ...<br /><br />implicit def findMyLogger: Logger = ...<br /><br />val mySandwich = makeMeASandwich<br /></code></pre> <p>The compiler, when you write <code>makeMeASandwich</code> without an explicit parameter, looks for an implicit in scope <em>of type <code>Logger</code></em>. Here, the obvious matching implicit is <code>findMyLogger</code>, because it <em>returns</em> a <code>Logger</code>. So the compiler selects the implicit and in effect rewrites your code as:</p> <pre><code class="scala">val mySandwich = makeMeASandwich(findMyLogger)</code></pre> <p>The same mechanism is at work with <code>implicit ev: T &lt;:&lt; U</code>: the compiler must find an implicit of type <code>T &lt;:&lt; U</code> (or <code>&lt;:&lt;[T, U]</code> which is exactly the same). And there is only one implicit definition with type <code>&lt;:&lt;</code>-of-something in the whole standard library, which is:</p> <pre><code class="scala">implicit def $conforms[A]: A &lt;:&lt; A</code></pre> <p>Now there is a bit of a twist, because the implicit is of type <code>&lt;:&lt;[A, A]</code>, with a <em>single</em> type parameter <code>A</code>, which in addition is abstract. <a href="#fn:12" id="fnref:12" title="see footnote" class="footnote">[12]</a> Anyhow, this means that our function parameter <code>ev</code> of type <code>&lt;:&lt;[T, U]</code> must, somehow, &#8220;match&#8221; with <code>&lt;:&lt;[A, A]</code>.</p> <p>If we ask ourselves: what does it take for this implicit of type <code>&lt;:&lt;[A, A]</code> to be successfully selected by the compiler? The answer is that one should be able, for some type <code>A</code> to be determined, to pass a value of type <code>&lt;:&lt;[A, A]</code> to the parameter of type <code>&lt;:&lt;[T, U]</code>. Another way to say this is that <code>&lt;:&lt;[A, A]</code> must <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#conformance"><em>conform</em></a> to <code>&lt;:&lt;[T, U]</code>. If we can&#8217;t do this, the implicit search will fail.</p> <h4 id="variance">Variance</h4> <p>How does this conformance work? This takes us to the notion of <em>variance</em>, which is always a fun thing. Consider a Scala immutable <code>Seq</code>. It is defined as <code>trait Seq[+A]</code>. The little <code>+</code> says that if I require a <code>Seq[Fruit]</code>, I can pass a <code>Seq[Banana]</code> just fine:</p> <pre><code class="scala">def takeFruits(fruits: Seq[Fruit]) = ...<br />takeFruits(Seq(new Banana))</code></pre> <p>This is called <em>covariance</em> (the subtyping of the type argument goes in the <em>same direction</em> as the enclosing type). Without the notion of covariance and contravariance (where subtyping of the type argument goes in the <em>opposite direction</em> as the enclosing type), you:</p> <ul><li>either can never write code like this (everything is <em>invariant</em>)</li><li>or you have an unsound type system <a href="#fn:13" id="fnref:13" title="see footnote" class="footnote">[13]</a></li></ul> <p>Besides collections, functions are another example where variance and contravariance matter. Say the following <code>process</code> function expects a single parameter, which is a function of one argument:</p> <pre><code class="scala">def process(f: Banana â Fruit)</code></pre> <p>I can of course pass to <code>process</code> a function with these exact same types:</p> <pre><code class="scala">def f1(f: Banana): Fruit = f<br />process(f1)</code></pre> <p>But Scala&#8217;s support for subtyping also applies to functions: a function can be a subtype of another function. So I can pass a function with types different from <code>Banana</code> and <code>Fruit</code> without breaking expectations as long as the function:</p> <ul><li>takes a parameter which is a supertype of <code>Banana</code></li><li>returns a value of a subtype of <code>Fruit</code></li></ul> <p>For example:</p> <pre><code class="scala">def f2(f: Fruit): Apple = new Apple<br />process(f2)</code></pre> <p>This is the magic of variance, and you can convince yourself that it makes sense from the point of view of the <code>process</code> function: expectations won&#8217;t be violated.</p> <p>Functions are not a special case in Scala from this point of view: a function of one parameter is defined (in a simplified version) as a trait with the function parameter as <em>contravariant</em> and the result as <em>covariant</em>:</p> <pre><code class="scala">trait Function1[-From, +To] { def apply(from: From): To }</code></pre> <h4 id="puttingeverythingtogether">Putting everything together</h4> <p>After this detour in variance land, let&#8217;s get back to <code>&lt;:&lt;</code> and the implicit parameter. The implicit <code>&lt;:&lt;[A, A]</code> will conform to the parameter <code>&lt;:&lt;[T, U]</code> if it follows the variance rules. So what&#8217;s the variance on <code>&lt;:&lt;[T, U]</code> in <code>Predef</code>?</p> <pre><code class="scala">&lt;:&lt;[-From, +To]</code></pre> <p>This is the same as <code>Function1[-From, +To]</code> and in fact <code>&lt;:&lt;</code> extends <code>Function1</code>! So our problem comes down to the following question: if somebody requires a function:</p> <pre><code class="scala">T â U</code></pre> <p>what constraints must be satisfied so I can pass the following function:</p> <pre><code class="scala">A â A</code></pre> <p>With variance rules, we know it will work if:</p> <ul><li><code>A</code> is supertype of <code>T</code></li><li>and <code>A</code> is subtype of <code>U</code></li></ul> <p>Written in terms of bounds:</p> <pre><code class="scala">T &lt;: A &lt;: U</code></pre> <p>Which means of course that <code>T &lt;: U</code>: <code>T</code> must be a subtype of <code>U</code>!</p> <p>To summarize the reasoning: the only eligible implicit definition in scope which can possibly be selected by the compiler to pass to our function is selected if and only if <code>T</code> is a subtype of <code>U</code>! And that&#8217;s exactly what we were looking for! <a href="#fn:14" id="fnref:14" title="see footnote" class="footnote">[14]</a></p> <p>You can look at this from a slightly more general angle, which is that a function <code>A â A</code> can only be passed to a function <code>T â U</code> if <code>T</code> is a subtype of <code>U</code>. <a href="#fn:15" id="fnref:15" title="see footnote" class="footnote">[15]</a> You can in fact test the matching logic very simply with the built-in <code>identity</code> function:</p> <pre><code class="scala">val f: Banana â Fruit  = identity // ok<br />val f: Fruit  â Banana = identity // not ok</code></pre> <p>The same works with <code>$conforms</code>, which returns an <code>&lt;:&lt;</code>, which is also an identity function:</p> <pre><code class="scala">val f: Banana â Fruit  = $conforms // ok<br />val f: Fruit  â Banana = $conforms // not ok</code></pre> <p>So it is a neat trick that the library authors <a href="#fn:16" id="fnref:16" title="see footnote" class="footnote">[16]</a> pulled off here, combining implicits and conformance of function types to implement constraint checking.</p> <h4 id="thenitty-gritty">The nitty-gritty</h4> <p>The rest of the related code in <code>Predef</code> is about defining the actual <code>&lt;:&lt;</code> type and creating a singleton instance returned by <code>def $conforms[A]</code>, because in case the implicit search matches, it must return a real value after all.</p> <p>You could write it minimally (using <code>&lt;::&lt;</code> in these attempts so as to not clash with the standard <code>&lt;:&lt;</code>):</p> <pre><code class="scala">sealed trait &lt;::&lt;[-From &lt;: To, +To] extends (From â To) {<br />  def apply(x: From): To = x<br />}<br /><br />implicit def $conforms[A]: A &lt;::&lt; A =<br />    new &lt;::&lt;[A, A] {}</code></pre> <p>But oops, the compiler complains:</p> <pre><code class="scala">scala&gt; def tupleIfSubtype[T, U](t: T, u: U)(implicit ev: T &lt;::&lt; U) = (t, u)<br />&lt;console&gt;:23: error: type arguments [T,U] do not conform to trait &lt;::&lt;&apos;s type parameter bounds [-From &lt;: To,+To]<br />       def tupleIfSubtype[T, U](t: T, u: U)(implicit ev: T &lt;::&lt; U) = (t, u)</code></pre> <p>The good news is that the following version, using an intermediate class, works:</p> <pre><code class="scala">sealed trait &lt;::&lt;[-From, +To] extends (From â To)<br /><br />final class $conformance[A] extends &lt;::&lt;[A, A] {<br />  def apply(x: A): A = x<br />}<br /><br />implicit def $conforms[A]: A &lt;::&lt; A =<br />  new $conformance[A]</code></pre> <p>So this works great, with a caveat: every time you use my version of <code>&lt;::&lt;</code>, a new instance of the anonymous class is created. Since we just want an identity function, which works the same for all types and doesn&#8217;t hold state, it would be good to use a singleton so as to avoid unnecessary allocations. We could try using an object, since that&#8217;s how we do singletons in Scala, but that&#8217;s a dead-end because objects cannot take type parameters:</p> <pre><code class="scala">scala&gt; implicit object Conforms[A] extends (A â A) { def apply(x: A): A = x }<br />&lt;console&gt;:1: error: &apos;;&apos; expected but &apos;[&apos; found.<br />implicit object Conforms[A] extends (A â A) { def apply(x: A): A = x }<br /></code></pre> <p>So in the end the standard implementation cheats by creating an untyped singleton using <code>Any</code>, and casting to <code>[A &lt;:&lt; A]</code> in the implementation of <code>$conforms</code>. Here is my attempt, which works fine:</p> <pre><code class="scala">private[this] final object Singleton_&lt;::&lt; extends &lt;::&lt;[Any, Any] {<br />  def apply(x: Any): Any = x<br />}<br /><br />implicit def $conforms[A]: A &lt;::&lt; A =<br />    Singleton_&lt;::&lt;.asInstanceOf[A &lt;::&lt; A]</code></pre> <p>The actual Scala implementation opts for using a <code>val</code> instead of an <code>object</code> (maybe to avoid the cost associated with an object&#8217;s lazy initialization):</p> <pre><code class="scala">private[this] final val singleton_&lt;:&lt; = new &lt;:&lt;[Any, Any] {<br />  def apply(x: Any): Any = x<br />}<br /><br />implicit def $conforms[A]: A &lt;:&lt; A =<br />    singleton_&lt;:&lt;.asInstanceOf[A &lt;:&lt; A]</code></pre> <p>We are only missing one last bit:</p> <pre><code class="scala">@implicitNotFound(msg = &quot;Cannot prove that ${From} &lt;:&lt; ${To}.&quot;)<br />sealed abstract class &lt;:&lt;[-From, +To] ...</code></pre> <p>This helps provide the user with a nice message when the implicit is not found. From a syntax perspective, it is a regular annotation, which applies to the abstract class <code>&lt;:&lt;</code>. The annotation is known by the compiler. <a href="#fn:17" id="fnref:17" title="see footnote" class="footnote">[17]</a></p> <p>So here we are: the implementation is explained! It&#8217;s a bit trickier than it should be in order to prevent extra allocations. I confess that I am a bit disappointed that there doesn&#8217;t seem to be a way to avoid an <code>instanceOf</code>: even though it&#8217;s local to the implementation and therefore the lack of safety remains under control, it would be better if it could be avoided.</p> <h4 id="animplicitconversion">An implicit conversion</h4> <p>One thing you might wonder is what to do with the <code>ev</code> parameter. After all, a value must be passed to the function when the implicit is found (when it&#8217;s not found, the compiler blows up so <code>ev</code> doesn&#8217;t need an actual value).</p> <p>A first answer is that you don&#8217;t absolutely need to use it. It&#8217;s there first so the compiler can check the constraint. That&#8217;s why it&#8217;s commonly called <code>ev</code>, for &#8220;evidence&#8221;: its presence stands there as a proof that something (an implicit) exists.</p> <p>Nonetheless, <code>ev</code> must have a value. What is it? It&#8217;s the <em>result</em> of the <code>$conforms[A]</code> function, which is of course of type <code>&lt;:&lt;[T, U]</code>. And we have seen above that <code>&lt;:&lt;</code> extends <code>T â U</code>. So the result of <code>$conforms[A]</code> is a <em>function</em>, which takes an <code>A</code> and returns an <code>A</code>, that is, an identity function. And it not only returns a value of the same type <code>A</code>, but it actually returns the same value which was passed (that&#8217;s the idea of an identity function).</p> <p>And you see that in the implementation:</p> <pre><code class="scala">def apply(x: Any): Any = x</code></pre> <p>It follows that <code>ev</code> has for value an identity function from <code>T</code> to <code>U</code>: it takes a value <code>t</code> of type <code>T</code> and returns that <em>same value</em> but with type <code>U</code>. This is possible, and makes sense, as we know that <code>T</code> is a subtype of <code>U</code>, otherwise the implicit wouldn&#8217;t have been found.</p> <p>But there is more: <code>ev</code> is also an <em>implicit conversion</em> from <code>T</code> to <code>U</code> (from <code>Banana</code> to <code>Fruit</code>). How so? Because it has the keyword <code>implicit</code> in front of it, that&#8217;s why!</p> <p>To contrast with regular type bounds, if you write:</p> <pre><code class="scala">def tupleIfSubtype[T &lt;: U, U](t: T, u: U) = ...</code></pre> <p>the compiler knows that <code>T</code> is a subtype of <code>U</code>, thanks of the native semantic of <code>&lt;:</code>. But with <code>&lt;:&lt;</code>, the compiler knows nothing of the sort based on the type parameter section.</p> <p>However the presence of the implicit <code>ev</code> function makes it possible to use the value <code>t</code> of type <code>T</code> as a value of type <code>U</code>. The subtype relationship can be seen as an implicit conversion. This is much safer than using <code>t.asInstanceOf[U]</code>. You could also be extra-explicit and write:</p> <pre><code class="scala">ev(t)</code></pre> <p>So you can write:</p> <pre><code class="scala">def tToU[T, U](t: T, u: U)(implicit ev: T &lt;:&lt; U): U = t</code></pre> <p>or:</p> <pre><code class="scala">def tToU[T, U](t: T, u: U)(implicit ev: T &lt;:&lt; U): U = ev(t)</code></pre> <p>Without the implicit conversion, the compiler complains:</p> <pre><code class="scala">scala&gt; def tToU[T, U](t: T, u: U): U = t<br />&lt;console&gt;:10: error: type mismatch;<br /> found   : t.type (with underlying type T)<br /> required: U<br />       def tToU[T, U](t: T, u: U): U = t<br /></code></pre> <p>You can see how <code>Option.flatten</code> makes use of the <code>ev()</code> function:</p> <pre><code>def flatten[B](implicit ev: A &lt;:&lt; Option[B]): Option[B] =<br />  if (isEmpty) None else ev(this.get)</code></pre> <p>In summary, all these features fall together to produce something that makes a lot of sense and is useful.</p> <h3 id="question4:isthereaneasierwaystoachievethesameresult">Question 4: Is there an easier ways to achieve the same result?</h3> <p>There is at least one other way something like what <code>&lt;:&lt;</code> does can be achieved. The idea is that a method such as <code>flatten</code> does not need to be included on the base class or trait, in this case <code>Option</code>. Instead, Scala has, via implicit conversions, what in effect achieves extension methods (AKA the &#8220;extend my library&#8221; pattern).</p> <p>So say that such an extension method is only available on values of type <code>Option[Option[T]]</code>:</p> <pre><code class="scala">implicit class OptionOption[T](val oo: Option[Option[T]]) extends AnyVal {<br />  def flattenMe: Option[T] = oo flatMap identity<br />}</code></pre> <p>If we try to apply it to <code>Some(Some(42))</code>, the method is found and the flattening works:</p> <pre><code class="scala">scala&gt; Some(Some(42)).flattenMe<br />res0: Option[Int] = Some(42)</code></pre> <p>If we try to apply it to <code>Some(42)</code>, the method is not found and the compiler reports an error:</p> <pre><code class="scala">scala&gt; Some(42).flattenMe<br />&lt;console&gt;:13: error: value flattenMe is not a member of Some[Int]<br />       Some(42).flattenMe</code></pre> <p>But I see a few differences with the <code>&lt;:&lt;</code> operator:</p> <ul><li>You need to create one implicit class for each type supporting a conversion. In the case of <code>Option</code>, for example, you need one implicit class taking an <code>Option[Option[T]</code> to support <code>flatten</code>, and another implicit class to support <code>orNull</code>. So this requires a bit more boilerplate than <code>&lt;:&lt;</code> per method.</li><li>I am not sure whether there something similar to <code>@implicitNotFound</code> to report a better error in case of problem.</li></ul> <p>So why not do it this way? I think that a good case can be made that it is easier to understand in the case of the relatively simple examples we have seen so far.</p> <p><strong>UPDATE 2015&#8211;12&#8211;10:</strong> Somebody <a href="https://www.reddit.com/r/scala/comments/3tyc8v/deconstructing_a_scala_feature_generalized_type/cxbanat">kindly pointed out</a> that at the time generalized type constraints were implemented, Scala didn&#8217;t yet have <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">value classes</a> or <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit classes</a>. Missing value classes meant boxing overhead when running extension methods, while missing implicit classes just meant more boilerplate. So using an implicit value class as I did above was not a great option at the time.</p> <p>On the other hand, <code>&lt;:&lt;</code> is a more flexible library feature which you can reuse easily and even combine with other implicits, like in this <a href="http://stackoverflow.com/questions/25149179/how-can-i-use-shapeless-to-create-a-function-abstracting-over-arity">example using Shapeless</a>: <a href="#fn:18" id="fnref:18" title="see footnote" class="footnote">[18]</a></p> <pre><code class="scala">def makeJava[F, A, L, S, R](f: F)(implicit<br />  ftp: FnToProduct.Aux[F, L =&gt; S],<br />  ev: S &lt;:&lt; Seq[R],<br />  ffp: FnFromProduct[L =&gt; JList[R]]<br />)</code></pre> <p>Finally, when using type bounds, the constraints expressed with <code>&lt;:</code> and <code>&gt;:</code> can only apply to the method type parameters (or class type parameters when they are used on a class). This is very useful, as we have seen. But when using <code>&lt;:&lt;</code>, you can constrain any two types in scope, and even impose multiple such constraints. Your imagination is the limit:</p> <pre><code class="scala">trait T[A, B] {<br /><br />  type C<br />  type D<br /><br />  def constrainTwoTraitParams         (implicit ev: A &lt;:&lt; B) = ()<br />  def constrainTraitParamAndTypeMember(implicit ev: A &lt;:&lt; C) = ()<br />  def constrainTwoTypeMembers         (implicit ev: C &lt;:&lt; D) = ()<br />  def constrainMore[Y](c: Y)          (implicit ev1: A &lt;:&lt; B, ev2: Y &lt;:&lt; C) = ()<br />}<br /><br />class C extends T[Banana, Fruit] {<br />  type U = Fruit<br />  type V = String<br />}<br /></code></pre> <p>You can even go further and constrain not only these types directly, but higher-order types, as in this (math- and symbol-heavy) <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">example from Miles Sabin</a>:</p> <pre><code>def size[T](t: T)(implicit ev: (Â¬Â¬[T] &lt;:&lt; (Int â¨ String))) = ???</code></pre> <p>In this case, the constraint is not directly on the <code>T</code> type parameter, but on <code>Â¬Â¬[T]</code>.</p> <p>This might be, after all, how the term &#8220;generalized type constraint&#8221; gets its name.</p> <h3 id="perspectives">Perspectives</h3> <p>We have seen how regular type bounds:</p> <ul><li>behave when using abstract type parameters</li><li>but don&#8217;t work to actually enforce certain useful constraints.</li></ul> <p>We have also seen how we can use instead a generalized type constraint expressed with <code>&lt;:&lt;</code>:</p> <ul><li>to implement methods which can only be used when types are aligned in a certain way</li><li>and how <code>&lt;:&lt;</code> is not a built-in feature of the compiler, but instead a library feature implemented via a smart trick involving implicit search and type conformance.</li></ul> <p>Finally, we have considered:</p> <ul><li>how the simple use cases in the standard library could be implemented differently</li><li>but also how <code>&lt;:&lt;</code> is a more general tool.</li></ul> <p>So is <code>&lt;:&lt;</code> is worth it? Should it be part of the standard library, and should Scala developers learn it?</p> <p>I think that the feature suffers from the fact that is is not properly documented, explained, and put in perspective. It also suffers from being a symbolic name with no agreed upon way to pronounce it!</p> <p>The standard library uses of <code>&lt;:&lt;</code> could be replaced with &#8220;extension methods&#8221;, which would achieve the same result via Scala features which are easier to understand and familiar to most Scala programmers. I think that this argues against the presence of <code>&lt;:&lt;</code> in the standard library, especially at the level of <code>Predef</code>, and if this was introduced today, my inclination would be to recommend leaving it to third-party libraries such as Shapeless which actually benefit the most from this kind of advanced features.</p> <p>On the plus side, when used <code>&lt;:&lt;</code> as a recipe, it is easy to understand and useful, and I can&#8217;t help but being impressed that generalized type constraints are implemented at the library level, and that they can emerge from powerful underlying language features such as type inference and implicits.</p> <p>This is typical of Scala, and in line with the principle of Martin Odersky that it is better to keep the core language small when possible. So even though the explanation of how <code>&lt;:&lt;</code> works might seem a bit tricky, you can take comfort in thinking that in other languages this might be compiler code, not library code. But I also understand how some programmers <a href="#fn:19" id="fnref:19" title="see footnote" class="footnote">[19]</a> might be bothered by all the machinery behind features like this.</p> <p>As for me, I am keeping generalized type constraints in my toolbox, but I like seeing the feature as a gateway to a more in-depth understanding of Scala. I hope this post will help others along this path as well!</p> <p><em>Did I get anything wrong? Please let me know!</em></p> <div class="footnotes"><hr /><ol> <li id="fn:1"><p>Other <a href="http://stackoverflow.com/questions/2603003/operator-in-scala/2603290">suggestions</a> include &#8220;Madonna wearing a button-down shirt&#8221; and &#8220;Angry Donkey&#8221;! <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:2"><p>It is valid to call this an <em>operator</em>, even though it is not built into the compiler, and is not an operator on values like <code>+</code>: it is instead an operator on <em>types</em>. In fact the Scala spec calls this <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#infix-types">an infix operator</a>. <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:3"><p><a href="http://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html">Using generalized type constraints - How to remove code with Scala 2.8</a>. <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:4"><p>I haven&#8217;t found a good explanation for the adjective <em>generalized</em>. This makes you think that there are more <em>specific</em> type constraints. But which are those then? <a href="#fnref:4" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:5"><p>It seems that there was another <code>&lt;%&lt;</code> operator as well, but it&#8217;s nowhere to be found in Scala 2.11. I suspect that, since it was related to the concept of <em>view bounds</em>, which are being deprecated, and probably had no use in the Scala standard library, it was removed at some point. <a href="#fnref:5" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:6"><p>The authors of the standard library could have used <code>=:=</code> to say that the type has to be <em>exactly</em> an <code>Option[B]</code>, but using the subtyping relationship allows the result of the expression to be a supertype. Assuming <code>Banana &lt;: Fruit</code>: <a href="#fnref:6" title="return to article" class="reversefootnote">&#160;&#8617;</a></p> <pre><code class="scala">scala&gt; Some(Some(new Banana)).flatten: Option[Fruit]<br />res2: Option[Fruit] = Some(Banana())</code></pre></li> <li id="fn:7"><p>&#8220;Lower bound&#8221; and &#8220;upper bound&#8221; refer to the type hierarchy: if you draw a type hierarchy with the supertypes at the top and subtypes at the bottom, &#8220;lower&#8221; means being closer to the bottom, and &#8220;upper&#8221; means closer to the top. So a &#8220;lower bound&#8221; for a type means the type cannot be under that. Similarly, an &#8220;upper bound&#8221; means the type cannot be above that. <a href="#fnref:7" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:8"><p>The compiler could have chosen the solution <code>Any</code> / <code>Any</code>, or <code>AnyRef</code> / <code>Any</code>. But these would be less useful and the compiler tries to be more specific when it can. <a href="#fnref:8" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:9"><p>The Typelevel team in particular <a href="https://github.com/typelevel/scala/issues/17">wants to address</a> that kind of not-very-useful type inference. <a href="#fnref:9" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:10"><p>That&#8217;s how all implicit searches work, see <a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">Where does Scala look for implicits?</a>. <a href="#fnref:10" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:11"><p>In a 2014 <a href="https://github.com/scala/scala/commit/4223bc2ddc497457c7dccd1b9b65e98244a9b4d1">commit</a>, the implementation switched to <code>$conforms</code> instead of <code>conforms</code> to avoid accidental shadowing. <a href="#fnref:11" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:12"><p>It is a bit unusual to see an implicit definition which is parametrized with an an abstract type parameter. Martin Odersky <a href="http://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html#Blog1_cmt-3000550784682205874">commented on this</a> in a blog post: &#8220;The new thing in 2.8 is that implicit resolution as a whole has been made more flexible, in that type parameters may now be instantiated by an implicits search. And that improvement made these classes useful.&#8221; <a href="#fnref:12" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:13"><p>Mutable Scala collections and arrays in Scala, in particular, are invariant so you cannot assign a <code>mutable.ArrayBuffer[Banana]</code> to a <code>mutable.ArrayBuffer[Fruit]</code>, or an <code>Array[Banana]</code> to an <code>Array[Fruit]</code>. <em>Immutable</em> Scala collections are covariant, because it is convenient and safe for them to be. Java arrays are covariant and therefore <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23">unsafe</a>! <a href="#fnref:13" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:14"><p>The compiler needs to be able to figure out conformance of types outside of implicit search, including every time you pass a parameter to a function. So it&#8217;s relatively easy to imagine how the compiler goes through the implicit search path, checking each available implicit, and pondering: &#8220;Does this particular implicit have a type which conforms to the required implicit parameter type? If so, I&#8217;ll use it, otherwise I&#8217;ll continue my search (and fail if the search ends without a match).&#8221;. <a href="#fnref:14" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:15"><p>In versions of Scala prior to 2.8, the predefined <code>identity</code> function was defined as <code>implicit</code>, and you could use it to implement generalized type constraints. However this early implementation had issues related to implicit search, therefore a new solution was implemented in 2.8 and <code>&lt;:&lt;</code> was introduced. But in fact <code>&lt;:&lt;</code> acts exactly like an implicit identity function under another name! <a href="(http://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html#c844646259627614220)">James Iry</a> commented on this topic: <a href="#fnref:15" title="return to article" class="reversefootnote">&#160;&#8617;</a></p> <blockquote><p>BTW, prior to 2.8 the idea could more or less be expressed with</p> <pre><code>def accruedInterest(convention: String)(implicit ev: I â CouponBond): Int = ...<br /></code></pre> <p>I say more or less because ev could be supplied by any implicit function that converts I to CouponBond. Normally you expect ev be the identity function, but of course somebody could have written an implicit conversion from say DiscountBond to CouponBond which would screw things up royally.</p></blockquote></li> <li id="fn:16"><p>Jason Zaugg <a href="https://gist.github.com/retronym/229163">appears</a> to be the mastermind behind it. <a href="#fnref:16" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:17"><p>Here is a short <a href="http://jsuereth.com/scala/2011/03/15/annotate-your-type-classes.html">blog post</a> on this annotation. <a href="#fnref:17" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:18"><p>For more uses of <code>&lt;:&lt;</code>, see <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">Unboxed union types in Scala via the Curry-Howard isomorphism</a> by Miles Sabin. <a href="#fnref:18" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> <li id="fn:19"><p>See <a href="http://yz.mit.edu/wp/true-scala-complexity/">Yang Zhang&#8217;s post</a>, which made some noise a while back. <a href="#fnref:19" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> </ol></div>