---
layout: post
title: Map.map vs. Map.mapValues
date: '2013-02-03T17:29:00.001-08:00'
author: Erik Bruchez
tags:
- programming
- scala
modified_time: '2015-11-12T09:43:38.716-08:00'
blogger_id: tag:blogger.com,1999:blog-2849901641571065621.post-3317894540003411035
blogger_orig_url: https://blog.bruchez.name/2013/02/mapmap-vs-mapmapvalues.html
---

<p>I just hit a bug caused by a misunderstanding of how <code>Map.mapValues</code> works. Consider:</p> <pre><code class="scala">val original = Map(&quot;a&quot; → 1, &quot;b&quot; → 2)<br />val modified = original map { case (k, v) ⇒ k → (v + 1) }</code></pre> <p>The result is an immutable map<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a> which is a transformation of the original map (all values are incremented by one). Once the <code>map</code> method terminates, the new map is actually holding those new values.</p> <p>Now <code>Map</code> also has a <code>mapValues</code> method, which seems like an attractive shortcut for the rather verbose transformation above. So you write:</p> <pre><code class="scala">val original = Map(&quot;a&quot; → 1, &quot;b&quot; → 2)<br />val modified = original mapValues (_ + 1)</code></pre> <p>More concise, right? But there is a catch: <code>map</code> and <code>mapValues</code> are different in a not-so-subtle way. <code>mapValues</code>, unlike <code>map</code>, returns a <em>view</em> on the original map. This view holds references to both the original map and to the transformation function (here <code>(_ + 1)</code>). Every time the returned map (view) is queried, the original map is first queried and the tranformation function is called on the result. You can see this in the source code of the Scala standard library:</p> <pre><code class="scala">override def mapValues[C](f: B =&gt; C): Map[A, C] = new DefaultMap[A, C] {<br />  ...<br />  def get(key: A) = self.get(key).map(f)<br />}</code></pre> <p>If the transformation function is referentially transparent, like <code>(_ + 1)</code>, all is well (besides performance considerations). But if not, you might be in for fun bugs depending on when the resulting map is queried. In my case, the transformation function depended on a context which, at a later point, was made invalid. When the resulting map was queried, the function-that-really-shouldn&#8217;t-run-now was running in that invalidated context and causing trouble.</p> <p>There is nothing inherently wrong with providing a view on the original map, but I would say the naming of <code>mapValues</code> violates the principle of least surprise: everybody knows the <code>map</code> method, and might reasonably assume that <code>mapValues</code> would behave in a similar way (and it doesn&#8217;t).</p> <p>Morality: when using <code>mapValues</code>, make sure the implications of using a view are acceptable, including making sure that your transformation function can safely run at the time the resulting map is queried. If not, prefer the good old <code>map</code> method. Oh, and also try to keep mutations local (but it&#8217;s often not easy).</p> <div class="footnotes"><hr /><ol> <li id="fn:1"><p>Scala has <code>Map</code> and <code>map</code>: <code>Map</code> denotes one of the traits for &#8220;a map from keys of type A to values of type B&#8221; (AKA a hash map), <code>map</code> is a method on collections, including <code>Map</code>, which &#8220;builds a new collection by applying a function to all elements of this map&#8221;. When I (and Scaladoc) use &#8220;map&#8221; as a noun, it means &#8220;it&#8217;s an instance of <code>Map</code>&#8221;. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></li> </ol></div>