<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Scala partial functions (without a PhD)" /><meta name="author" content="Erik Bruchez" /><meta property="og:locale" content="en_US" /><meta name="description" content="If you have done some Scala for a while, you know about pattern matching and match/case. Things like:" /><meta property="og:description" content="If you have done some Scala for a while, you know about pattern matching and match/case. Things like:" /><link rel="canonical" href="https://blog.bruchez.name/posts/scala-partial-functions-without-phd/" /><meta property="og:url" content="https://blog.bruchez.name/posts/scala-partial-functions-without-phd/" /><meta property="og:site_name" content="Erik’s Ponderings" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2011-10-15T12:54:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Scala partial functions (without a PhD)" /><meta name="twitter:site" content="@ebruchez" /><meta name="twitter:creator" content="@Erik Bruchez" /><meta name="google-site-verification" content="irueyGKya5E07oltkTU3FJThmPxkQy-n1W1GOClvPIQ" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Erik Bruchez"},"dateModified":"2021-02-02T23:28:16-08:00","datePublished":"2011-10-15T12:54:00-07:00","description":"If you have done some Scala for a while, you know about pattern matching and match/case. Things like:","headline":"Scala partial functions (without a PhD)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bruchez.name/posts/scala-partial-functions-without-phd/"},"url":"https://blog.bruchez.name/posts/scala-partial-functions-without-phd/"}</script><title>Scala partial functions (without a PhD) | Erik's Ponderings</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/public/headshot.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Erik's Ponderings</a></div><div class="site-subtitle font-italic">A blog and More</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/pages/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>PAGES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ebruchez" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ebruchez" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['erik','bruchez.org'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://feeds.feedburner.com/EriksPondering" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Scala partial functions (without a PhD)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Scala partial functions (without a PhD)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 15, 2011, 12:54 PM -0700" > Oct 15, 2011 <i class="unloaded">2011-10-15T12:54:00-07:00</i> </span> by <span class="author"> Erik Bruchez </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 2, 2021, 11:28 PM -0800" > Feb 2, 2021 <i class="unloaded">2021-02-02T23:28:16-08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1609 words">8 min</span></div><div class="post-meta mb-3"> <a href='/categories/programming/'>Programming</a></div></div><div class="post-content"><p>If you have done some Scala for a while, you know about pattern matching and <code class="language-plaintext highlighter-rouge">match/case</code>. Things like:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">value</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="err">…</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="err">…</span>
<span class="o">}</span>
</pre></table></code></div></div><p>But there is another use of the <code class="language-plaintext highlighter-rouge">case</code> keyword, without <code class="language-plaintext highlighter-rouge">match</code>, as in:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">map</span> <span class="n">foreach</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span>
</pre></table></code></div></div><p>The first time I saw this kind of things I was a bit puzzled: in which situations could <code class="language-plaintext highlighter-rouge">case</code> be used without <code class="language-plaintext highlighter-rouge">match</code>? Well, it turns out <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> that a block with a bunch of <code class="language-plaintext highlighter-rouge">case</code> inside is one way of defining an <em>anonymous function</em>.</p><p>There is nothing new with anonymous functions of course, and Scala has a very compact notation for those that doesn’t involve <code class="language-plaintext highlighter-rouge">case</code>. But this particular way of defining anonymous functions gives you a lot for free, namely all the good things of pattern matching like casting-done-right, guards, and destructuring. The example above, with <code class="language-plaintext highlighter-rouge">foreach</code>, shows how case can be used for destructuring the tuples of the map into key and value components.</p><p>But there is more. Consider:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">41</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>
<span class="nv">scala</span><span class="o">.</span><span class="py">MatchError</span><span class="k">:</span> <span class="kt">cat</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">java.lang.String</span><span class="o">)</span>
</pre></table></code></div></div><p>As expected this crashes, because the pattern match doesn’t know what to do when the string “cat” is passed to it.</p><p>On the other hand, this example doesn’t crash:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">41</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span> <span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>So what’s the difference? Does <code class="language-plaintext highlighter-rouge">collect</code> just catch the <code class="language-plaintext highlighter-rouge">MatchError</code> and proceed? That would be clumsy and inefficient. In fact, the apparent magic lies in the fact that <code class="language-plaintext highlighter-rouge">case</code> blocks define special functions called <em>partial functions</em>. <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></p><p>Now you might wonder, coming from a “normal” programming language background, what it means, for a function to be “partial”. Well, it <a href="http://en.wikipedia.org/wiki/Partial_function">comes from mathematics</a>, where it’s opposed to “total” functions.</p><p>But even though it comes from math it’s actually simple. Take for example this function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">inc</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</pre></table></code></div></div><p>It is <em>defined</em> for any <code class="language-plaintext highlighter-rouge">Int</code> input value. That means for that any <code class="language-plaintext highlighter-rouge">Int</code> argument, it produces a resulting <code class="language-plaintext highlighter-rouge">Int</code> result. <sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup></p><p>A partial function on the other hand is defined only for a <em>subset</em> of the possible values of its arguments:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">fraction</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">42</span> <span class="o">/</span> <span class="n">d</span>
</pre></table></code></div></div><p>is not defined for <code class="language-plaintext highlighter-rouge">d == 0</code> and <code class="language-plaintext highlighter-rouge">fraction(0)</code> will throw an exception. Think also of the square root function, which is not defined for negative real numbers. Examples abound. And it’s true also for the <code class="language-plaintext highlighter-rouge">collect</code> example above, where the anonymous function is only defined for an <code class="language-plaintext highlighter-rouge">Int</code> argument but not for a <code class="language-plaintext highlighter-rouge">String</code> (or any other) argument.</p><p>So you get the idea about some values not “making sense” as the argument of a function because they can’t yield a significant result.</p><p>Now if you think about it you will notice lots of situations like this in your programs, where functions are expected to work properly only for some input values. If the function is called with a disallowed value, it will typically crash, yield a special return value, or throw an exception (and this should better be documented). In short, partial function are very common in real-life programs even if you don’t know about it.</p><p>So here <code class="language-plaintext highlighter-rouge">fraction</code> is defined as a regular function, but conceptually it is a partial function. The good thing is that Scala has built-in support for partial functions thanks to the <code class="language-plaintext highlighter-rouge">PartialFunction</code> trait. And here is one way of defining such a partial function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">fraction</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">42</span> <span class="o">/</span> <span class="n">d</span>
  <span class="k">def</span> <span class="nf">isDefinedAt</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></table></code></div></div><p>A <code class="language-plaintext highlighter-rouge">PartialFunction</code> must provides a method <code class="language-plaintext highlighter-rouge">isDefinedAt</code>, which allows the caller of the partial function to know, beforehand, whether the function can return a result for a given input value:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">fraction</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">fraction</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></table></code></div></div><p>And if you call the function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">fraction</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">fraction</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span>
</pre></table></code></div></div><p>This takes us back to the use of <code class="language-plaintext highlighter-rouge">case</code> to define partial functions. The exact same function can be written:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">fraction</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">{</span> <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">d</span> <span class="kt">!=</span> <span class="err">0</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
</pre></table></code></div></div><p>(Notice that you must specify that the <code class="language-plaintext highlighter-rouge">PartialFunction[Int, Int]</code> type. It would be great if Scala had a syntax to make this even more compact but it doesn’t as of Scala 2.11.)</p><p>And if you call the function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">fraction</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">fraction</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nv">scala</span><span class="o">.</span><span class="py">MatchError</span><span class="k">:</span> <span class="err">0</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">java.lang.Integer</span><span class="o">)</span>
</pre></table></code></div></div><p>(Note that there is one visible difference from the outside when you use the case way: you get a <code class="language-plaintext highlighter-rouge">MatchError</code> as you usually do with pattern matching.)</p><p>The idea doesn’t apply only to numbers. In our <code class="language-plaintext highlighter-rouge">collect</code> example above, the partial function implicitly defined looks like this:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">incAny</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">{</span> <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>
</pre></table></code></div></div><p>The function takes an <code class="language-plaintext highlighter-rouge">Any</code> as parameter because <code class="language-plaintext highlighter-rouge">List(41, "cat")</code> is a <code class="language-plaintext highlighter-rouge">List[Any]</code>. But it is only defined for inputs that are of type <code class="language-plaintext highlighter-rouge">Int</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">incAny</span><span class="o">(</span><span class="mi">41</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">incAny</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="nv">scala</span><span class="o">.</span><span class="py">MatchError</span><span class="k">:</span> <span class="kt">cat</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">java.lang.String</span><span class="o">)</span>
</pre></table></code></div></div><p>Passing a <code class="language-plaintext highlighter-rouge">String</code> didn’t go too well, as expected. But now you can check this before calling the function with:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">incAny</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">41</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">incAny</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></table></code></div></div><p>So we now have the explanation for the difference in behavior between <code class="language-plaintext highlighter-rouge">collect</code> and <code class="language-plaintext highlighter-rouge">map</code>, which is that <code class="language-plaintext highlighter-rouge">collect</code> expects a partial function. It asks <code class="language-plaintext highlighter-rouge">incAny</code> whether it is defined for <code class="language-plaintext highlighter-rouge">41</code> and then <code class="language-plaintext highlighter-rouge">"cat"</code>, and so automatically filters out <code class="language-plaintext highlighter-rouge">"cat"</code>. Another cool thing here is that the Scala compiler can even infer a clean resulting collection type: <code class="language-plaintext highlighter-rouge">List[Int]</code>!</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">41</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span> <span class="n">collect</span> <span class="n">incAny</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>Also, as you notice, if you define the partial function inline, the compiler knows that it’s a partial function and you avoid the explicit <code class="language-plaintext highlighter-rouge">PartialFunction</code> trait.</p><p>Notice that partial functions can lie:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">liar</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">{</span> <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">toInt</span> <span class="o">}</span>
<span class="n">liar</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">liar</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">liar</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">liar</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">NumberFormatException</span><span class="k">:</span> <span class="kt">For</span> <span class="kt">input</span> <span class="kt">string:</span> <span class="err">"</span><span class="kt">cat</span><span class="err">"</span>
</pre></table></code></div></div><p>Here <code class="language-plaintext highlighter-rouge">liar</code> says incorrectly that it’s defined for <code class="language-plaintext highlighter-rouge">"cat"</code>. It would probably be better to write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">honest</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">{</span> <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">;</span> <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">if</span> <span class="kt">isParsableAsInt</span><span class="o">(</span><span class="kt">s</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">toInt</span> <span class="o">}</span>
<span class="n">honest</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">honest</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></table></code></div></div><p>So now you see how partial functions defined with <code class="language-plaintext highlighter-rouge">case</code> can be used for things like <code class="language-plaintext highlighter-rouge">collect</code> with a super compact notation. You will see them in other places, including catch expressions.</p><p>There is another situation in Scala where partial functions are “just there” and you might not know it. Take the following List:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">pets</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"frog"</span><span class="o">)</span>
</pre></table></code></div></div><p>In Scala, any instance of <code class="language-plaintext highlighter-rouge">Seq</code>, <code class="language-plaintext highlighter-rouge">Set</code> or <code class="language-plaintext highlighter-rouge">Map</code> is also a function. So you can write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">pets</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">cat</span>
</pre></table></code></div></div><p>But:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">pets</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">IndexOutOfBoundsException</span><span class="k">:</span> <span class="err">3</span>
</pre></table></code></div></div><p>Wouldn’t that mean that the <code class="language-plaintext highlighter-rouge">pets</code> function is, hum, only <em>defined</em> for values <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, and <code class="language-plaintext highlighter-rouge">2</code>? Sounds familiar? Wouldn’t it be cool to look at pets as a partial function then? Well you can because in Scala any instance of <code class="language-plaintext highlighter-rouge">Seq</code> or <code class="language-plaintext highlighter-rouge">Map</code> (but not <code class="language-plaintext highlighter-rouge">Set</code>) is actually a partial function. So you can write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></table></code></div></div><p>And if you had a list of indexes and wanted to safely collect values for these indexes in a new list, you could write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span> <span class="n">collect</span> <span class="n">pets</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">frog</span><span class="o">)</span>
</pre></table></code></div></div><p>Here it works well because <code class="language-plaintext highlighter-rouge">collect</code> handles everything for us. But it can be a pain to check <code class="language-plaintext highlighter-rouge">isDefinedAt</code> all over the place. If anything, it feels a bit like a <code class="language-plaintext highlighter-rouge">null</code> check, and we hate those in Scala. The good news is that in Scala the <code class="language-plaintext highlighter-rouge">PartialFunction</code> trait supports the <code class="language-plaintext highlighter-rouge">lift</code> method, which converts the partial function to a normal function that doesn’t crash:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></table></code></div></div><p>As you see the <code class="language-plaintext highlighter-rouge">lift</code> returns a function that returns an <code class="language-plaintext highlighter-rouge">Option</code> of the value. This allows you to safely process values without <code class="language-plaintext highlighter-rouge">null</code> checks and without calling <code class="language-plaintext highlighter-rouge">isDefinedAt</code> yourself:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="s">"I love my "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> <span class="n">getOrElse</span> <span class="s">""</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">I</span> <span class="n">love</span> <span class="n">my</span> <span class="n">cat</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">pets</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="s">"I love my "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> <span class="n">getOrElse</span> <span class="s">""</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="s">""</span>
</pre></table></code></div></div><p>I hope this helps make some sense of partial functions in Scala.</p><p><em>NOTE: This post was updated on 2014-12-27 to fix the use of <code class="language-plaintext highlighter-rouge">def</code> where <code class="language-plaintext highlighter-rouge">val</code> was called for, based on user comments. A few typos have been corrected as well.</em></p><p><em>NOTE: This post was updated on 2017-01-17 to address the fact that <code class="language-plaintext highlighter-rouge">Set</code> is not a partial function, as kindly noted by a reader.</em></p><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1"><p>From The Scala Language Specification: “An anonymous function can be defined by a sequence of cases […] which appear as an expression without a prior match.” <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2"><p>This is not to be confused with <em>partially applied functions</em>, which are a completely different topic. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:3"><p>In Scala, it is defined even for <code class="language-plaintext highlighter-rouge">Int.MaxValue</code>, as <code class="language-plaintext highlighter-rouge">Int.MaxValue + 1 == Int.MinValue</code>. The result is just plain wrong but it’s defined! <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Updates</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vail-resorts-epic-coverage-declined/">Beware of Vail Resorts' Epic Coverage</a><li><a href="/posts/restoring-ibm-memory-typewriter-1/">Restoring an IBM Memory Typewriter - Part 1</a><li><a href="/posts/apple-1-reproduction-part-7-audio-cassette-adapter/">Building an Apple-1 Reproduction in 2024/2025 - Part 7: The Audio Cassette Adapter</a><li><a href="/posts/apple-1-reproduction-part-6-c-programming/">Building an Apple-1 Reproduction in 2024/2025 - Part 6: C Programming</a><li><a href="/posts/apple-1-reproduction-part-3-retro-chip-tester/">Building an Apple-1 Reproduction in 2024 - Part 3: The Retro Chip Tester</a></ul></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/continuations-in-scala/"><div class="card-body"> <span class="timeago small" > Sep 17, 2011 <i class="unloaded">2011-09-17T16:15:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Continuations in Scala (without a PhD)</h3><div class="text-muted small"><p> With @avernet we have been thinking lately about continuations, for a few reasons: Continuations pop up on the web as a concept that could help with event-based programming Scala has a contin...</p></div></div></a></div><div class="card"> <a href="/posts/scala-tip-import-renames/"><div class="card-body"> <span class="timeago small" > Jun 18, 2012 <i class="unloaded">2012-06-18T16:44:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala tip: import renames</h3><div class="text-muted small"><p> In Java, you often write things like this, which are rather verbose: 1 2 URLEncoder.encode(...) URLDecoder.decode(...) Since Java 1.5 you can use static imports, but then you are stuck with the ...</p></div></div></a></div><div class="card"> <a href="/posts/scala-tip-getorelseupdate/"><div class="card-body"> <span class="timeago small" > Jun 30, 2012 <i class="unloaded">2012-06-30T09:24:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala tip: getOrElseUpdate</h3><div class="text-muted small"><p> I found myself recently looking at the following code which I wrote when I was getting started with Scala: 1 2 3 4 5 6 7 8 def getModelState(modelPrefixedId: String) = modelStates.get(modelPrefi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/continuations-in-scala/" class="btn btn-outline-primary" prompt="Older"><p>Continuations in Scala (without a PhD)</p></a> <a href="/posts/scala-tip-import-renames/" class="btn btn-outline-primary" prompt="Newer"><p>Scala tip: import renames</p></a></div><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script> var disqus_config = function() { this.page.url = 'https://blog.bruchez.name/posts/scala-partial-functions-without-phd/'; this.page.identifier = '/posts/scala-partial-functions-without-phd/'; }; (function() { var d = document; var s = d.createElement('script'); s.src = 'https://ebruchez.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="">Erik Bruchez</a>.</p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.bruchez.name{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
