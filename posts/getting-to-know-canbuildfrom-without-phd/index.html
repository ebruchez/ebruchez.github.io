<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Getting to know CanBuildFrom (without a PhD)" /><meta name="author" content="Erik Bruchez" /><meta property="og:locale" content="en_US" /><meta name="description" content="Recently I needed to write a pretty simple function: given a sequence of (name, value) pairs, return a sequence of (name, some collection of all the values having that name) pairs. Here is a simple implementation:" /><meta property="og:description" content="Recently I needed to write a pretty simple function: given a sequence of (name, value) pairs, return a sequence of (name, some collection of all the values having that name) pairs. Here is a simple implementation:" /><link rel="canonical" href="https://blog.bruchez.name/posts/getting-to-know-canbuildfrom-without-phd/" /><meta property="og:url" content="https://blog.bruchez.name/posts/getting-to-know-canbuildfrom-without-phd/" /><meta property="og:site_name" content="Erik’s Ponderings" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2012-08-20T14:33:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Getting to know CanBuildFrom (without a PhD)" /><meta name="twitter:site" content="@ebruchez" /><meta name="twitter:creator" content="@Erik Bruchez" /><meta name="google-site-verification" content="irueyGKya5E07oltkTU3FJThmPxkQy-n1W1GOClvPIQ" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Erik Bruchez"},"dateModified":"2021-02-02T23:28:16-08:00","datePublished":"2012-08-20T14:33:00-07:00","description":"Recently I needed to write a pretty simple function: given a sequence of (name, value) pairs, return a sequence of (name, some collection of all the values having that name) pairs. Here is a simple implementation:","headline":"Getting to know CanBuildFrom (without a PhD)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bruchez.name/posts/getting-to-know-canbuildfrom-without-phd/"},"url":"https://blog.bruchez.name/posts/getting-to-know-canbuildfrom-without-phd/"}</script><title>Getting to know CanBuildFrom (without a PhD) | Erik's Ponderings</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/public/headshot.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Erik's Ponderings</a></div><div class="site-subtitle font-italic">A blog and More</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/pages/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>PAGES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ebruchez" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ebruchez" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['erik','bruchez.org'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://feeds.feedburner.com/EriksPondering" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Getting to know CanBuildFrom (without a PhD)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Getting to know CanBuildFrom (without a PhD)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 20, 2012, 2:33 PM -0700" > Aug 20, 2012 <i class="unloaded">2012-08-20T14:33:00-07:00</i> </span> by <span class="author"> Erik Bruchez </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 2, 2021, 11:28 PM -0800" > Feb 2, 2021 <i class="unloaded">2021-02-02T23:28:16-08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1437 words">7 min</span></div><div class="post-meta mb-3"> <a href='/categories/programming/'>Programming</a></div></div><div class="post-content"><p>Recently I needed to write a pretty simple function: given a sequence of <code class="language-plaintext highlighter-rouge">(name, value)</code> pairs, return a sequence of <code class="language-plaintext highlighter-rouge">(name, some collection of all the values having that name)</code> pairs. Here is a simple implementation:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">combineValues</span><span class="o">(</span><span class="n">pairs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]()</span>

  <span class="nf">for</span> <span class="o">((</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">pairs</span><span class="o">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">value</span> <span class="o">::</span> <span class="nv">result</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">))</span>

  <span class="nv">result</span><span class="o">.</span><span class="py">toList</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Then I realized that I not only needed the result as a <code class="language-plaintext highlighter-rouge">Seq[(String, Seq[String])]</code>, but also as a <code class="language-plaintext highlighter-rouge">Seq[(String, Array[AnyRef])]</code>, for compatibility with a Java API. I could of course transform one into the other, but I wondered whether there might be a way to directly return the desired collection type (without duplicating the function!).</p><p>Let’s think a little bit about what this entails: the revised <code class="language-plaintext highlighter-rouge">combineValues</code> needs to create <em>new collections</em> of a type specified by the caller. So first the type needs to be specified, which means that the function needs to take so-called <em>type parameters</em>: one for the resulting collection type, and one for the item type:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">import</span> <span class="nn">language.higherKinds</span> <span class="c1">// so that Scala 2.10 doesn't warn</span>
<span class="k">def</span> <span class="nf">combineValues</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">pairs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">])]</span>
</pre></table></code></div></div><p>The type parameters are specified with the funny <code class="language-plaintext highlighter-rouge">[U, T[_]]</code> declaration before the usual function parameters. You have probably seen this syntax on generic classes. But functions can have type parameters too!</p><p>Also, the function now says it returns values of type <code class="language-plaintext highlighter-rouge">T[U]</code>. The idea here is that we will return collections of type <code class="language-plaintext highlighter-rouge">T</code> where <code class="language-plaintext highlighter-rouge">T</code> stands for things like <code class="language-plaintext highlighter-rouge">Seq</code>, <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Set</code> containing elements of type <code class="language-plaintext highlighter-rouge">U</code>, where <code class="language-plaintext highlighter-rouge">U</code> stands for <code class="language-plaintext highlighter-rouge">String</code> or <code class="language-plaintext highlighter-rouge">AnyRef</code>.</p><p>Do you see what we’ve done here? We have changed the signature to be more abstract: instead of specifying beforehand that we are dealing with <code class="language-plaintext highlighter-rouge">Seq</code> or <code class="language-plaintext highlighter-rouge">Array</code> or <code class="language-plaintext highlighter-rouge">String</code>, we use “variables” (<code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code>). In case you are wondering, there is nothing magic about the names <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code>, we could have used <code class="language-plaintext highlighter-rouge">Coll</code> and <code class="language-plaintext highlighter-rouge">Elem</code> instead. It’s a matter of taste.</p><p>A couple of remarks on the syntax:</p><ul><li>It’s not possible to just specify <code class="language-plaintext highlighter-rouge">[T[U]]</code> as a single type parameter: the two parameters must be separate.<li>Because <code class="language-plaintext highlighter-rouge">T</code> is a type which itself takes a parameter, we must say so with <code class="language-plaintext highlighter-rouge">T[_]</code> (<code class="language-plaintext highlighter-rouge">T[Whatever]</code> works too).</ul><p>Here is how you call the function with explicit type parameters (sometimes, type parameters can be inferred by the compiler, but not here):</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">combineValues</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">](</span><span class="n">seq</span><span class="o">)</span>
</pre></table></code></div></div><p>Now the function needs to make use of these type parameters to create the new collections. How do we do that?</p><p>Naively, let’s try creating new empty collections of type <code class="language-plaintext highlighter-rouge">T[U]</code> using a constructor:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="c1">// incorrect Scala</span>
</pre></table></code></div></div><p>or, using a companion object’s <code class="language-plaintext highlighter-rouge">apply</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]()</span> <span class="c1">// incorrect Scala</span>
</pre></table></code></div></div><p>Unfortunately, neither even compiles. How would something like this work anyway? You could imagine that the runtime type information is available to <code class="language-plaintext highlighter-rouge">combineValues</code> and then use reflection to create new instances. But:</p><ul><li>Scala erases parametrized types during compilation, and type parameters are not automatically available at runtime (although there are ways to obtain them).<li>The collection type parameter could be a trait, like <code class="language-plaintext highlighter-rouge">Seq</code>, in which case you would have to find a reasonable concrete class implementing that trait. How would you go about making that determination?<li>This would result in instantiating empty instances of the resulting collection. How would you add elements to that collection? <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">List</code> in particular aren’t <code class="language-plaintext highlighter-rouge">Growable</code> collections. So you would have to find a constructor taking all the items of the collection instead. That’s possible, but not guaranteed to work at runtime for all types.<li>This might not be very efficient due to the use of reflection.</ul><p>So besides the fact that it does not work out of the box, this approach is not as simple as it first looked. We are missing something, and that something is a <em>factory</em> for the collection to create. And Scala already has a trait for that kind of factories in the Scala standard library: it is called <a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html#scala.collection.generic.CanBuildFrom"><code class="language-plaintext highlighter-rouge">CanBuildFrom</code></a>.</p><p>This trait is a bit of a funny thing: it is part of many Scala collections function signatures, and for that reason has been the <a href="http://stackoverflow.com/questions/1722726/is-the-scala-2-8-collections-library-a-case-of-the-longest-suicide-note-in-hist">target</a> of criticism, with the result that Scala 2.8’s Scaladoc hides it from signatures by default. <a href="http://grahamhackingscala.blogspot.com/2011/01/scala-pragmatism-ignore-canbuildfrom.html">Some</a> have argued that it’s not necessary to understand it to use Scala collections, and I agree with that (in general, Scala collections just work even if you don’t have any idea that <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> exists).</p><p>This said, <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> itself is a pretty simple thing conceptually: if you have an instance of <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> for a given collection type, you can call <code class="language-plaintext highlighter-rouge">apply</code> on it to get a <code class="language-plaintext highlighter-rouge">Builder</code> for that collection. Once you have the builder, you just add elements to it, and finally obtain the resulting collection. The trait itself is parametrized, to specify a source collection type, an element type, and a resulting collection type: <code class="language-plaintext highlighter-rouge">CanBuildFrom[-From, -Elem, +To]</code>.</p><p>Here, what we want is a <code class="language-plaintext highlighter-rouge">CanBuildFrom[T[U], U, T[U]]</code>. The first type parameter, the <code class="language-plaintext highlighter-rouge">From</code> collection, does not seem to be consequential here.) In short it’s a factory able to return a <code class="language-plaintext highlighter-rouge">Builder</code> for a collection <code class="language-plaintext highlighter-rouge">T[U]</code>.</p><p>A version of our function receiving a <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> looks like this:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">combineValues</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
  <span class="n">pairs</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)],</span>
  <span class="n">cbf</span>   <span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>, <span class="kt">U</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Builder</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]]]()</span>

  <span class="nf">for</span> <span class="o">((</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">pairs</span><span class="o">)</span>
    <span class="nv">result</span><span class="o">.</span><span class="py">getOrElseUpdate</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="nf">cbf</span><span class="o">())</span> <span class="o">+=</span> <span class="n">value</span>

  <span class="n">result</span> <span class="n">map</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="nv">v</span><span class="o">.</span><span class="py">result</span> <span class="o">}</span> <span class="n">toList</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Note where the factory is called: <code class="language-plaintext highlighter-rouge">cbf()</code>, and where the resulting collection is obtained: <code class="language-plaintext highlighter-rouge">v.result</code>.</p><p>But how does the caller even <em>obtain</em> a <code class="language-plaintext highlighter-rouge">CanBuildFrom</code>? You have not only to pass <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> (the type parameters) but also somehow figure out where to locate that factory.</p><p>Of course, and this is why the Scala collections and <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> are designed this way in the first place, there is a twist: <em>implicit parameters</em>. The idea is that instead of finding and passing the factory explicitly to the function, the compiler does that for you. So we change the signature as follows:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">combineValues</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">pairs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cbf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>, <span class="kt">U</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">[</span><span class="kt">U</span><span class="o">])]</span>
</pre></table></code></div></div><p>Notice how we changed <code class="language-plaintext highlighter-rouge">cbf</code> from a regular parameter to an implicit parameter with the <code class="language-plaintext highlighter-rouge">implicit</code> keyword, and moved it to a second parameter list (yes, Scala supports more than one parameter list).</p><p>When the compiler sees a call to such a function, it does something called an <em>implicit search</em>. This is the process whereby it locates an appropriate value for the implicit parameter, based on the function scope and parameters (see <a href="http://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits">more on implicit search</a>). Importantly, it looks at the <em>type</em> of the implicit parameter. Here this means that the value must be of type <code class="language-plaintext highlighter-rouge">CanBuildFrom</code>, with the proper type parameters too.</p><p>The Scala collections have such factories already, and they are nicely made available to implicit search when you use collection types such as <code class="language-plaintext highlighter-rouge">Seq</code> and <code class="language-plaintext highlighter-rouge">Array</code>. So the compiler will find them without trouble.</p><p>So say we call the function like this:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">combineValues</span><span class="o">[</span><span class="kt">AnyRef</span>, <span class="kt">Array</span><span class="o">](</span><span class="n">seq</span><span class="o">)</span>
<span class="n">combineValues</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">](</span><span class="n">seq</span><span class="o">)</span>
</pre></table></code></div></div><p>The compiler will respectively search for the following <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> instances, and pass them to the function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">]</span>, <span class="kt">AnyRef</span>, <span class="kt">Array</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">]]</span>
<span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
</pre></table></code></div></div><p>And it will just work!</p><p>The result? We have a achieved more than what we were looking for: we have a function able to return a result made of any existing collection available in the standard library, or even outside of the standard library, for that matter. The resulting collection can be anything you want as long as there is a <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> for the resulting type. Most notably, <code class="language-plaintext highlighter-rouge">Array</code> is a plain Java array, and it works because Scala provides a <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> for it. It’s a powerful approach.</p><p>From the caller side, things remain easy: you call your function as usual except that you specify the type of the result you want.</p><p>Is there magic here? No: it is all done thanks to the clever design of implicit parameters and their use within the standard Scala collections. And the great thing is that the mechanics of it are available to anybody, not just to the compiler or Scala standard library maintainers.</p><p>What to think of the type parameters and the implicit <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> factory? They certainly lead to more abstract programming, but when put in simple terms, like “here is a function which can return a result based on any collection type you want, as long as the compiler finds a factory for that type”, I think it sounds quite reasonable.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Updates</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vail-resorts-epic-coverage-declined/">Beware of Vail Resorts' Epic Coverage</a><li><a href="/posts/restoring-ibm-memory-typewriter-1/">Restoring an IBM Memory Typewriter - Part 1</a><li><a href="/posts/apple-1-reproduction-part-7-audio-cassette-adapter/">Building an Apple-1 Reproduction in 2024/2025 - Part 7: The Audio Cassette Adapter</a><li><a href="/posts/apple-1-reproduction-part-6-c-programming/">Building an Apple-1 Reproduction in 2024/2025 - Part 6: C Programming</a><li><a href="/posts/apple-1-reproduction-part-3-retro-chip-tester/">Building an Apple-1 Reproduction in 2024 - Part 3: The Retro Chip Tester</a></ul></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/continuations-in-scala/"><div class="card-body"> <span class="timeago small" > Sep 17, 2011 <i class="unloaded">2011-09-17T16:15:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Continuations in Scala (without a PhD)</h3><div class="text-muted small"><p> With @avernet we have been thinking lately about continuations, for a few reasons: Continuations pop up on the web as a concept that could help with event-based programming Scala has a contin...</p></div></div></a></div><div class="card"> <a href="/posts/scala-partial-functions-without-phd/"><div class="card-body"> <span class="timeago small" > Oct 15, 2011 <i class="unloaded">2011-10-15T12:54:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala partial functions (without a PhD)</h3><div class="text-muted small"><p> If you have done some Scala for a while, you know about pattern matching and match/case. Things like: value match { case Some(value) =&gt; … case None =&gt; … } But there is another use of t...</p></div></div></a></div><div class="card"> <a href="/posts/scala-tip-import-renames/"><div class="card-body"> <span class="timeago small" > Jun 18, 2012 <i class="unloaded">2012-06-18T16:44:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala tip: import renames</h3><div class="text-muted small"><p> In Java, you often write things like this, which are rather verbose: URLEncoder.encode(...) URLDecoder.decode(...) Since Java 1.5 you can use static imports, but then you are stuck with the orig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/more-iterators-goodness/" class="btn btn-outline-primary" prompt="Older"><p>More iterators goodness</p></a> <a href="/posts/implicit-conversion-to-unit-type-in/" class="btn btn-outline-primary" prompt="Newer"><p>Implicit conversion to the Unit type in Scala</p></a></div><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script> var disqus_config = function() { this.page.url = 'https://blog.bruchez.name/posts/getting-to-know-canbuildfrom-without-phd/'; this.page.identifier = '/posts/getting-to-know-canbuildfrom-without-phd/'; }; (function() { var d = document; var s = d.createElement('script'); s.src = 'https://ebruchez.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="">Erik Bruchez</a>.</p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.bruchez.name{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
