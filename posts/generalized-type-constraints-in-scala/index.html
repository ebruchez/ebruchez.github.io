<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Generalized type constraints in Scala (without a PhD)" /><meta name="author" content="Erik Bruchez" /><meta property="og:locale" content="en_US" /><meta name="description" content="Introduction" /><meta property="og:description" content="Introduction" /><link rel="canonical" href="https://blog.bruchez.name/posts/generalized-type-constraints-in-scala/" /><meta property="og:url" content="https://blog.bruchez.name/posts/generalized-type-constraints-in-scala/" /><meta property="og:site_name" content="Erik’s Ponderings" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2015-11-17T09:47:00-08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Generalized type constraints in Scala (without a PhD)" /><meta name="twitter:site" content="@ebruchez" /><meta name="twitter:creator" content="@Erik Bruchez" /><meta name="google-site-verification" content="irueyGKya5E07oltkTU3FJThmPxkQy-n1W1GOClvPIQ" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Erik Bruchez"},"dateModified":"2021-02-04T11:01:40-08:00","datePublished":"2015-11-17T09:47:00-08:00","description":"Introduction","headline":"Generalized type constraints in Scala (without a PhD)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bruchez.name/posts/generalized-type-constraints-in-scala/"},"url":"https://blog.bruchez.name/posts/generalized-type-constraints-in-scala/"}</script><title>Generalized type constraints in Scala (without a PhD) | Erik's Ponderings</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/public/headshot.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Erik's Ponderings</a></div><div class="site-subtitle font-italic">A blog and More</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/pages/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>PAGES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ebruchez" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ebruchez" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['erik','bruchez.org'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://feeds.feedburner.com/EriksPondering" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Generalized type constraints in Scala (without a PhD)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Generalized type constraints in Scala (without a PhD)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Nov 17, 2015, 9:47 AM -0800" > Nov 17, 2015 <i class="unloaded">2015-11-17T09:47:00-08:00</i> </span> by <span class="author"> Erik Bruchez </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Feb 4, 2021, 11:01 AM -0800" > Feb 4, 2021 <i class="unloaded">2021-02-04T11:01:40-08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6470 words">35 min</span></div><div class="post-meta mb-3"> <a href='/categories/programming/'>Programming</a></div></div><div class="post-content"><h2 id="introduction">Introduction</h2><p>Not long ago I stumbled upon the signature of the <code class="language-plaintext highlighter-rouge">flatten</code> method on <code class="language-plaintext highlighter-rouge">Option</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">flatten</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</pre></table></code></div></div><p>I don’t know about you, but I knew about implicit parameter lists, implicit resolution, and even type bounds. But this funny <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> “sad-with-a-hat” <sup id="fnref:operator-name"><a href="#fn:operator-name" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> operator <sup id="fnref:operator"><a href="#fn:operator" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> was entirely new to me!</p><p>Smart people <sup id="fnref:debasishg"><a href="#fn:debasishg" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> have written about it years ago, but it’s clear that we are talking about a feature which is not well-known and poorly documented, even though it is available since Scala 2.8. So this article is about figuring out what it means and how it works.</p><p>The following deconstruction turns out to be fairly long, but even though <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> itself may not be useful to every Scala programmer, it touches a surprisingly large number of Scala features which most Scala programmers should know.</p><h2 id="what-it-does-and-how-its-useful">What it does and how it’s useful</h2><p>If you search the Scala standard library, you find a few other occurrences of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, in particular:</p><ul><li>on <code class="language-plaintext highlighter-rouge">Option</code>:<div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">orNull</span><span class="o">[</span><span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Null</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A1</span><span class="o">)</span><span class="k">:</span> <span class="kt">A1</span>
</pre></table></code></div></div><li>on <code class="language-plaintext highlighter-rouge">Traversable</code> (via traits like <code class="language-plaintext highlighter-rouge">GenTraversableOnce</code>):<div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">toMap</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="o">(</span><span class="kt">K</span><span class="o">,</span> <span class="kt">V</span><span class="o">))</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>
</pre></table></code></div></div><li>on <code class="language-plaintext highlighter-rouge">Either</code>:<div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">joinRight</span><span class="o">[</span><span class="kt">A1</span> <span class="k">&gt;:</span> <span class="kt">A</span>, <span class="kt">B1</span> <span class="k">&gt;:</span> <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">B1</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">C</span><span class="o">]</span>
</pre></table></code></div></div><li>on <code class="language-plaintext highlighter-rouge">Try</code>:<div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">flatten</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
</pre></table></code></div></div></ul><p>You notice that, in all these examples, <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> is used in the same way:</p><ul><li>there is an implicit parameter list, with a single parameter called <code class="language-plaintext highlighter-rouge">ev</code><li>the <em>type</em> of this parameter is of the form <code class="language-plaintext highlighter-rouge">Type1 &lt;:&lt; Type2</code></ul><p>The lowdown is that this pattern tells the compiler:</p><blockquote><p>Make sure that <code class="language-plaintext highlighter-rouge">Type1</code> is a <em>subtype</em> of <code class="language-plaintext highlighter-rouge">Type2</code>, or else report an error.</p></blockquote><p>This is part of a feature called <em>generalized type constraints</em>. <sup id="fnref:name-generalized-type-constraints"><a href="#fn:name-generalized-type-constraints" class="footnote" rel="footnote" role="doc-noteref">4</a></sup> There is another similar construct, <code class="language-plaintext highlighter-rouge">=:=</code>, which tells the compiler: <sup id="fnref:view-type"><a href="#fn:view-type" class="footnote" rel="footnote" role="doc-noteref">5</a></sup></p><blockquote><p>Make sure that <code class="language-plaintext highlighter-rouge">Type1</code> is <em>exactly the same</em> as <code class="language-plaintext highlighter-rouge">Type2</code>, or else report an error.</p></blockquote><p>In what follows, I am focusing on <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> which turns out to be more useful, but just know that <code class="language-plaintext highlighter-rouge">=:=</code> is a thing and works in a very similar way.</p><p>The <em>why</em> and <em>how</em> of this feature is the subject of the rest of this article! So for now, let’s take this as a recipe, a trick if you will, while we look at how this can be useful in practice.</p><p>Let’s start with <code class="language-plaintext highlighter-rouge">flatten</code> on <code class="language-plaintext highlighter-rouge">Option</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">flatten</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</pre></table></code></div></div><p>What does <code class="language-plaintext highlighter-rouge">flatten</code> do, as per the documentation? It removes a level of nesting of options:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">oo</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
<span class="n">oo</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">oo</span><span class="o">.</span><span class="py">flatten</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>This doesn’t make much sense if the type parameter <code class="language-plaintext highlighter-rouge">A</code> of <code class="language-plaintext highlighter-rouge">Option</code> is not, itself, an <code class="language-plaintext highlighter-rouge">Option</code>-of-something. So what should happen if you call <code class="language-plaintext highlighter-rouge">flatten</code> on, say, an <code class="language-plaintext highlighter-rouge">Option[String]</code>? I see two possibilities:</p><ol><li>The <code class="language-plaintext highlighter-rouge">flatten</code> method returns <code class="language-plaintext highlighter-rouge">None</code>.<li>The compiler reports an error.</ol><p>The authors of the Scala standard library picked option 2, and I think that it’s a good choice, because most likely calling <code class="language-plaintext highlighter-rouge">flatten</code> in this case is not what the programmer intends. And lo and behold, the compiler doesn’t let this pass:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">oi</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">oi</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">oi</span><span class="o">.</span><span class="py">flatten</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">Int</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">].</span>
       <span class="nv">oi</span><span class="o">.</span><span class="py">flatten</span>
</pre></table></code></div></div><p>So we have a generic type, <code class="language-plaintext highlighter-rouge">Option[+A]</code>, which has a method, <code class="language-plaintext highlighter-rouge">flatten</code>, which can only be used if the type parameter <code class="language-plaintext highlighter-rouge">A</code> is itself an <code class="language-plaintext highlighter-rouge">Option</code>. All the other methods (except <code class="language-plaintext highlighter-rouge">orNull</code> which is similar to <code class="language-plaintext highlighter-rouge">flatten</code>) can be called: <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">get</code>, etc. But <code class="language-plaintext highlighter-rouge">flatten</code>? Only if the type of the option is right!</p><p>One thing to realize is that we have something unusual here: a method which the compiler won’t let us call, not because we pass incorrect parameters to the method (in fact <code class="language-plaintext highlighter-rouge">flatten</code> doesn’t even take any explicit parameters), but based on the value of a <em>type parameter</em> of the underlying <code class="language-plaintext highlighter-rouge">Option</code> class. This is not something you see in Java, and you have probably rarely seen it in Scala.</p><p>Looking again at the signature of <code class="language-plaintext highlighter-rouge">flatten</code>, we can see how the recipe is applied: <code class="language-plaintext highlighter-rouge">implicit ev: A &lt;:&lt; Option[B]</code> reads “make sure that <code class="language-plaintext highlighter-rouge">A</code> is a subtype of <code class="language-plaintext highlighter-rouge">Option[B]</code>”, and, since <code class="language-plaintext highlighter-rouge">A</code> stands for the parameter type of <code class="language-plaintext highlighter-rouge">Option</code>, we have:</p><ul><li>in the first case “make sure that <code class="language-plaintext highlighter-rouge">Option[Int]</code> is a subtype of <code class="language-plaintext highlighter-rouge">Option[B]</code>”<li>in the second case “make sure that <code class="language-plaintext highlighter-rouge">Int</code> is a subtype of <code class="language-plaintext highlighter-rouge">Option[B]</code>”</ul><p>Obviously, <code class="language-plaintext highlighter-rouge">Option[Int]</code> can be a subtype of an <code class="language-plaintext highlighter-rouge">Option[B]</code>, where <code class="language-plaintext highlighter-rouge">B = Int</code> (or <code class="language-plaintext highlighter-rouge">B = AnyVal</code>, or <code class="language-plaintext highlighter-rouge">B = Any</code>). On the flip side, there is just no way <code class="language-plaintext highlighter-rouge">Int</code> can be a subtype of <code class="language-plaintext highlighter-rouge">Option[B]</code>, whatever <code class="language-plaintext highlighter-rouge">B</code> might be. So the recipe works, and therefore the constraint works. <sup id="fnref:subtype-instead-of-exact"><a href="#fn:subtype-instead-of-exact" class="footnote" rel="footnote" role="doc-noteref">6</a></sup></p><p>To get the hang of it, let’s look at another nice use case , <code class="language-plaintext highlighter-rouge">toMap</code> on <code class="language-plaintext highlighter-rouge">Traversable</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">toMap</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="o">(</span><span class="kt">K</span><span class="o">,</span> <span class="kt">V</span><span class="o">))</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>
</pre></table></code></div></div><p>Translated into English: you can convert a <code class="language-plaintext highlighter-rouge">Traversable</code> to a <code class="language-plaintext highlighter-rouge">Map</code> with <code class="language-plaintext highlighter-rouge">toMap</code>, but only if the element type is a tuple <code class="language-plaintext highlighter-rouge">(K, V)</code>. This makes sense, because a <code class="language-plaintext highlighter-rouge">Map</code> can be seen as a collection of key/value tuples. It wouldn’t make great sense to create a <code class="language-plaintext highlighter-rouge">Map</code> just out of a sequence of 5 <code class="language-plaintext highlighter-rouge">Int</code>s, for example.</p><p>Similar rationales apply to the few other uses of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> in the standard library, which all come down to constraining methods to work with a specific contained type only.</p><p>In light of these examples, I find that applying this recipe is easy, even though the syntax is a bit funny. But I can think of a few questions:</p><ol><li>Can’t we just use <em>type bounds</em> which I thought existed to enforce this kind of type constraints?<li>If this is a <em>pattern</em> rather than a built-in feature, why does <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> look so much like an operator? Does the compiler have special support for it?<li>How does this whole thing even work?<li>Is there an easier ways to achieve the same result?</ol><p>Let’s look into each of these questions in order.</p><h2 id="question-1-cant-we-just-use-type-bounds">Question 1: Can’t we just use type bounds?</h2><h3 id="lower-and-upper-bounds">Lower and upper bounds</h3><p><em>Type bounds</em> cover <em>lower bounds</em> and <em>upper bounds</em>. <sup id="fnref:bounds-naming"><a href="#fn:bounds-naming" class="footnote" rel="footnote" role="doc-noteref">7</a></sup> These are well explained in the book <a href="http://www.artima.com/pins1ed/type-parameterization.html#19.5">Programming in Scala</a>, so I won’t cover the basics here, but I will present some perspective on how they work.</p><p>As a reminder, lower and upper bounds are expressed with <em>builtin syntax</em>: <code class="language-plaintext highlighter-rouge">&gt;:</code> and <code class="language-plaintext highlighter-rouge">&lt;:</code> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#type-parameters">spec</a>). You can read:</p><ul><li><code class="language-plaintext highlighter-rouge">T &gt;: U</code> as “type <code class="language-plaintext highlighter-rouge">T</code> is a supertype of type <code class="language-plaintext highlighter-rouge">U</code>” or “type <code class="language-plaintext highlighter-rouge">T</code> has type <code class="language-plaintext highlighter-rouge">U</code> as lower bound”<li><code class="language-plaintext highlighter-rouge">T &lt;: U</code> as “type <code class="language-plaintext highlighter-rouge">T</code> is a subtype of type <code class="language-plaintext highlighter-rouge">U</code>” or “type <code class="language-plaintext highlighter-rouge">T</code> has type <code class="language-plaintext highlighter-rouge">U</code> as upper bound”</ul><h3 id="a-puzzler">A puzzler</h3><p>Let’s consider the following:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
<span class="n">tuple</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span><span class="o">,</span> <span class="n">U</span><span class="err">]</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>
</pre></table></code></div></div><p>My <code class="language-plaintext highlighter-rouge">tuple</code> function simply returns a tuple of the two values passed, whatever their types might be. Granted, it’s not very useful!</p><p>What are <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code>? They are type variables: they <em>stand for</em> actual types that will be decided at each call site (each use of the function in the source code). Here both <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are <em>abstract</em>: we don’t know what they will be when we write the function. For example we don’t say that <code class="language-plaintext highlighter-rouge">U</code> is a <code class="language-plaintext highlighter-rouge">Banana</code>, which would be a <em>concrete</em> type.</p><p>If we pass <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Int</code> parameters, we get back a tuple <code class="language-plaintext highlighter-rouge">(String, Int)</code> in the Scala REPL:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">tuple</span><span class="o">(</span><span class="s">"Lincoln"</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Lincoln</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>Now let’s consider the following modification, which is a naive attempt at enforcing type constraints with type bounds:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">U</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></table></code></div></div><p>I know, it’s starting to be like an alphabet (and symbol) soup! But let’s stay calm: the only change is that instead of specifying just <code class="language-plaintext highlighter-rouge">T</code> as type parameter, we specify <code class="language-plaintext highlighter-rouge">T &lt;: U</code>, which means “<code class="language-plaintext highlighter-rouge">T</code> must be a subtype of <code class="language-plaintext highlighter-rouge">U</code>”.</p><p>The intent of <code class="language-plaintext highlighter-rouge">tupleIfSubtype</code> is to return a tuple of the two values passed, like <code class="language-plaintext highlighter-rouge">tuple</code> above, but fail at compile time if the first value is not a subtype of the second value.</p><p>So does the newly added constraint work? Do you think that the compiler will accept to compile this?</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">tupleIfSubtype</span><span class="o">(</span><span class="s">"Lincoln"</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>Before knowing better, I would have thought that the compiler:</p><ul><li>would decide that <code class="language-plaintext highlighter-rouge">T = String</code><li>would decide that <code class="language-plaintext highlighter-rouge">U = Int</code><li>see the type constraint <code class="language-plaintext highlighter-rouge">T &lt;: U</code>, which translates into <code class="language-plaintext highlighter-rouge">String &lt;: Int</code><li>fail compilation because obviously, <code class="language-plaintext highlighter-rouge">String</code> is not a subtype of <code class="language-plaintext highlighter-rouge">Int</code></ul><p>But it turns out that this actually compiles just fine!</p><p>How can this be? Is the constraint not considered? Is it a bug in the compiler? A weird edge case? Bad language design? Or maybe, with <code class="language-plaintext highlighter-rouge">T &lt;: U</code>, the <code class="language-plaintext highlighter-rouge">U</code> is not the same as the second <code class="language-plaintext highlighter-rouge">U</code> in the type parameter section? This can quickly be proven false:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">V</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="k">type</span> <span class="kt">V</span>
       <span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">V</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></table></code></div></div><p>So the two <code class="language-plaintext highlighter-rouge">U</code>s are, as seemed to make sense intuitively, <em>bound</em> to each other (they refer to the same type).</p><p>The answer to this puzzler turns out to be relatively simple: it has to do with the way type inference works, namely that type inference solves a <em>constraint system</em> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#local-type-inference">spec</a>).</p><p>What happens is that yes, I do pass <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Int</code>, but it doesn’t follow that <code class="language-plaintext highlighter-rouge">T = String</code> and <code class="language-plaintext highlighter-rouge">U = Int</code>. Instead, the effective <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are the <em>result</em> of the compiler working its type inference algorithm, given:</p><ul><li>the types of the parameters we actually pass to the function,<li>the constraints expressed in the type parameter section,<li>and, in some cases, the expression’s return type.</ul><p>If I write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
<span class="n">tuple</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span><span class="o">,</span> <span class="n">U</span><span class="err">]</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">tuple</span><span class="o">(</span><span class="s">"Lincoln"</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Lincoln</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>then yes: <code class="language-plaintext highlighter-rouge">T = String</code> and <code class="language-plaintext highlighter-rouge">U = Int</code> because there are no other constraints. But when I introduce an upper bound, there <em>is</em> a constraint, and therefore a constraint system. The compiler resolves it and obtains <code class="language-plaintext highlighter-rouge">T = String</code> and <code class="language-plaintext highlighter-rouge">U = Any</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">U</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
<span class="n">tupleIfSubtype</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">U</span><span class="o">,</span> <span class="n">U</span><span class="err">]</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">tupleIfSubtype</span><span class="o">(</span><span class="s">"Lincoln"</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Lincoln</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>We can verify that the resulting types satisfy the constraints: <sup id="fnref:other-solutions"><a href="#fn:other-solutions" class="footnote" rel="footnote" role="doc-noteref">8</a></sup></p><ul><li><code class="language-plaintext highlighter-rouge">String</code> is a <code class="language-plaintext highlighter-rouge">String</code> of course<li><code class="language-plaintext highlighter-rouge">Int</code> is a subtype of <code class="language-plaintext highlighter-rouge">Any</code><li><code class="language-plaintext highlighter-rouge">String</code> is also a subtype of <code class="language-plaintext highlighter-rouge">Any</code></ul><p>Phew! So this makes sense. It’s “just” a matter of understanding how type inference works when type bounds are present.</p><p>In the process we have learned that <code class="language-plaintext highlighter-rouge">&lt;:</code> and <code class="language-plaintext highlighter-rouge">&gt;:</code>, when used with abstract type parameters, do not necessarily produce results which are very useful, because the compiler can easily infer <code class="language-plaintext highlighter-rouge">Any</code> (or <code class="language-plaintext highlighter-rouge">AnyVal</code> or <code class="language-plaintext highlighter-rouge">AnyRef</code>) as solutions to the constraint system. <sup id="fnref:typelevel-any-inference"><a href="#fn:typelevel-any-inference" class="footnote" rel="footnote" role="doc-noteref">9</a></sup></p><h2 id="question-2-why-does-look-so-much-like-an-operator">Question 2: Why does &lt;:&lt; look so much like an operator?</h2><p>Lets dig a little deeper to understand how <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> works under the hood. Here is a simple type hierarchy used in the examples below:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Apple</span>  <span class="k">extends</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Banana</span> <span class="k">extends</span> <span class="nc">Fruit</span>
</pre></table></code></div></div><h3 id="parameter-lists-and-type-inference">Parameter lists and type inference</h3><p>Let’s start with a couple more things you need to know in Scala:</p><ul><li>Functions can have more than one parameter list.<li>Type inference operates parameter list per parameter list from left to right.</ul><p>In particular, an <em>implicit</em> parameter list can use types inferred in previous parameter lists.</p><p>So let’s write the solution, without necessarily understanding it fully yet:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></table></code></div></div><p>This function has two parameter lists:</p><ul><li><code class="language-plaintext highlighter-rouge">(t: T, u: U)</code><li><code class="language-plaintext highlighter-rouge">(implicit ev: T &lt;:&lt; U)</code></ul><p>Because type inference goes parameter list by parameter list, let’s start with the first one. You notice that there are no <code class="language-plaintext highlighter-rouge">&gt;:</code> or <code class="language-plaintext highlighter-rouge">&lt;:</code> type bounds! So:</p><ul><li><code class="language-plaintext highlighter-rouge">T</code> is whatever specific type <code class="language-plaintext highlighter-rouge">t</code> has (say <code class="language-plaintext highlighter-rouge">T = Banana</code>)<li><code class="language-plaintext highlighter-rouge">U</code> is whatever specific type <code class="language-plaintext highlighter-rouge">u</code> has (say <code class="language-plaintext highlighter-rouge">U = Fruit</code>)</ul><h3 id="infix-types">Infix types</h3><p>Looking at the second parameter list, we have to clear a hurdle: what kind of syntax is <code class="language-plaintext highlighter-rouge">T &lt;:&lt; U</code>? This notation is called an <em>infix type</em> (<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#infix-types">spec</a>). “Infix” just means that a type appears <em>in the middle</em> of two other types, the same way the <code class="language-plaintext highlighter-rouge">+</code> operator appears in the middle in <code class="language-plaintext highlighter-rouge">2 + 2</code>. The type in the middle (the infix type proper) can be referred to a an <em>infix operator</em>. Instead of this operator being a method, as is the case in general in Scala, it is a <em>type</em>.</p><p>Let’s look at examples. You probably know types from the standard library such as:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Fruit</span><span class="o">]</span>
<span class="nc">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Boolean</span><span class="o">]</span>
</pre></table></code></div></div><p>These exact same types can be written:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="nc">Map</span> <span class="nc">Fruit</span>
<span class="nc">String</span> <span class="nc">Either</span> <span class="nc">Boolean</span>
</pre></table></code></div></div><p>The infix notation makes the parametrized type look like an operator, but an operator on <em>types</em> instead of <em>values</em>. Other than that, it’s just an alternate syntax, and really nothing to worry about!</p><p>So based on the above:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="o">&lt;:&lt;</span> <span class="n">U</span>
</pre></table></code></div></div><p>means the the same as:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">&lt;:&lt;[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">]</span>
</pre></table></code></div></div><h3 id="a-symbolic-type-name">A symbolic type name</h3><p>Now, what is a <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>? It’s a type: the same kind of stuff as <code class="language-plaintext highlighter-rouge">Map</code> or <code class="language-plaintext highlighter-rouge">Either</code>, in other words, typically a class or a trait. It’s just that this is a symbolic name instead of an alphabetic identifier like <code class="language-plaintext highlighter-rouge">Map</code>. It could as well have been called <code class="language-plaintext highlighter-rouge">SubtypeOf</code>, and maybe it should have been!</p><h3 id="the-implicit-parameter">The implicit parameter</h3><p>So once we reach the second (and implicit) parameter list:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">U</span><span class="o">)</span>
</pre></table></code></div></div><p>we see that there is a parameter of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, which itself has two type parameters, <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code>. These are the <em>same</em> <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> we have in the first parameter list. They are <em>bound</em> to those, and these are known because type inference already did its magic on the first parameter list. Concretely, <code class="language-plaintext highlighter-rouge">T</code> is now assigned the type <code class="language-plaintext highlighter-rouge">Banana</code> and <code class="language-plaintext highlighter-rouge">U</code> the type <code class="language-plaintext highlighter-rouge">Fruit</code>!</p><p>What the implicit parameter list says is this: “Find me, somewhere in the implicit search path, an implicit <code class="language-plaintext highlighter-rouge">val</code>, <code class="language-plaintext highlighter-rouge">def</code>, or <code class="language-plaintext highlighter-rouge">class</code> of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> which satisfies <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code>”. <sup id="fnref:implicit-search"><a href="#fn:implicit-search" class="footnote" rel="footnote" role="doc-noteref">10</a></sup> And because <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are now known, we need to find an implicit match for <code class="language-plaintext highlighter-rouge">&lt;:&lt;[Banana, Fruit]</code>.</p><p>The trick is to manage to have an implicit definition in scope which matches <em>only</em> if there is a <em>subtype</em> relationship between <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code>. For example:</p><div class="table-wrapper"><table><thead><tr><th>T<th>U<th>Compiler Happiness Level<tbody><tr><td><code class="language-plaintext highlighter-rouge">Banana</code><td><code class="language-plaintext highlighter-rouge">Fruit</code><td>happy<tr><td><code class="language-plaintext highlighter-rouge">Apple</code><td><code class="language-plaintext highlighter-rouge">Fruit</code><td>happy<tr><td><code class="language-plaintext highlighter-rouge">Int</code><td><code class="language-plaintext highlighter-rouge">Anyval</code><td>happy<tr><td><code class="language-plaintext highlighter-rouge">Apple</code><td><code class="language-plaintext highlighter-rouge">Banana</code><td>unhappy<tr><td><code class="language-plaintext highlighter-rouge">String</code><td><code class="language-plaintext highlighter-rouge">Int</code><td>unhappy</table></div><p>If we manage to create such an implicit definition, the constraint mechanism works. And we already know that the clever engineers who devised this have found a way to create such an implicit definition!</p><p>By the way, we can play with this in the REPL using the standard <code class="language-plaintext highlighter-rouge">implicitly</code> function, which returns an implicit value for the given type parameter if one is found:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">implicitly</span><span class="o">[</span><span class="kt">Banana</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Fruit</span><span class="o">]</span>  <span class="c1">// ok</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">Apple</span>  <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Fruit</span><span class="o">]</span>  <span class="c1">// ok</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">Int</span>    <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Anyval</span><span class="o">]</span> <span class="c1">// ok</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">Apple</span>  <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Banana</span><span class="o">]</span> <span class="c1">// not ok</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">String</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Int</span><span class="o">]</span>    <span class="c1">// not ok</span>
</pre></table></code></div></div><p>To summarize, we now have a pretty good level of understanding and we know that:</p><ul><li>we are talking about a library feature<li>which relies on an implicit parameter<li>with a funny symbolic type operator <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>.</ul><p>And we also know that the magic that makes it all work lies in the search for a matching implicit definition: if it is found, the subtyping relationship holds, otherwise it doesn’t and the compiler reports and error.</p><h2 id="question-3-how-does-this-whole-thing-even-work">Question 3: How does this whole thing even work?</h2><p>We could stop here and be happy to use <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> like a recipe, as if it was a core language feature. But that wouldn’t be very satisfying, would it? After all, we still miss the <em>deeper</em> understanding of how that magic implicit is defined, and why an implicit search for it may or may not match it. So let’s keep going!</p><h3 id="the-implementation">The implementation</h3><p>Let’s look at the implementation of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, which we find in the Scala <code class="language-plaintext highlighter-rouge">Predef</code> object <sup id="fnref:conforms-shadowing"><a href="#fn:conforms-shadowing" class="footnote" rel="footnote" role="doc-noteref">11</a></sup>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@implicitNotFound</span><span class="o">(</span><span class="n">msg</span> <span class="k">=</span> <span class="s">"Cannot prove that ${From} &lt;:&lt; ${To}."</span><span class="o">)</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">&lt;:&lt;</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">+To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Serializable</span>

<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">val</span> <span class="nv">singleton_&lt;:&lt;</span> <span class="k">=</span> <span class="k">new</span> <span class="o">&lt;:&lt;[</span><span class="kt">Any</span>, <span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">singleton_&lt;:&lt;</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A</span><span class="o">]</span>
</pre></table></code></div></div><p>Wow! Can we figure it out? Let’s try.</p><h3 id="which-implicit">Which implicit?</h3><p>Let’s think about a simpler case of implicit search:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">makeMeASandwich</span><span class="o">(</span><span class="k">implicit</span> <span class="n">logger</span><span class="k">:</span> <span class="kt">Logger</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">findMyLogger</span><span class="k">:</span> <span class="kt">Logger</span> <span class="o">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="nv">mySandwich</span> <span class="k">=</span> <span class="n">makeMeASandwich</span>
</pre></table></code></div></div><p>The compiler, when you write <code class="language-plaintext highlighter-rouge">makeMeASandwich</code> without an explicit parameter, looks for an implicit in scope <em>of type <code class="language-plaintext highlighter-rouge">Logger</code></em>. Here, the obvious matching implicit is <code class="language-plaintext highlighter-rouge">findMyLogger</code>, because it <em>returns</em> a <code class="language-plaintext highlighter-rouge">Logger</code>. So the compiler selects the implicit and in effect rewrites your code as:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">mySandwich</span> <span class="k">=</span> <span class="nf">makeMeASandwich</span><span class="o">(</span><span class="n">findMyLogger</span><span class="o">)</span>
</pre></table></code></div></div><p>The same mechanism is at work with <code class="language-plaintext highlighter-rouge">implicit ev: T &lt;:&lt; U</code>: the compiler must find an implicit of type <code class="language-plaintext highlighter-rouge">T &lt;:&lt; U</code> (or <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code> which is exactly the same). And there is only one implicit definition with type <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>-of-something in the whole standard library, which is:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A</span>
</pre></table></code></div></div><p>Now there is a bit of a twist, because the implicit is of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code>, with a <em>single</em> type parameter <code class="language-plaintext highlighter-rouge">A</code>, which in addition is abstract. <sup id="fnref:implicit-type-parameters-instantiation"><a href="#fn:implicit-type-parameters-instantiation" class="footnote" rel="footnote" role="doc-noteref">12</a></sup> Anyhow, this means that our function parameter <code class="language-plaintext highlighter-rouge">ev</code> of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code> must, somehow, “match” with <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code>.</p><p>If we ask ourselves: what does it take for this implicit of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code> to be successfully selected by the compiler? The answer is that one should be able, for some type <code class="language-plaintext highlighter-rouge">A</code> to be determined, to pass a value of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code> to the parameter of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code>. Another way to say this is that <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code> must <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#conformance"><em>conform</em></a> to <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code>. If we can’t do this, the implicit search will fail.</p><h3 id="variance">Variance</h3><p>How does this conformance work? This takes us to the notion of <em>variance</em>, which is always a fun thing. Consider a Scala immutable <code class="language-plaintext highlighter-rouge">Seq</code>. It is defined as <code class="language-plaintext highlighter-rouge">trait Seq[+A]</code>. The little <code class="language-plaintext highlighter-rouge">+</code> says that if I require a <code class="language-plaintext highlighter-rouge">Seq[Fruit]</code>, I can pass a <code class="language-plaintext highlighter-rouge">Seq[Banana]</code> just fine:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">takeFruits</span><span class="o">(</span><span class="n">fruits</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Fruit</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
<span class="nf">takeFruits</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">Banana</span><span class="o">))</span>
</pre></table></code></div></div><p>This is called <em>covariance</em> (the subtyping of the type argument goes in the <em>same direction</em> as the enclosing type). Without the notion of covariance and contravariance (where subtyping of the type argument goes in the <em>opposite direction</em> as the enclosing type), you:</p><ul><li>either can never write code like this (everything is <em>invariant</em>)<li>or you have an unsound type system <sup id="fnref:unsafe"><a href="#fn:unsafe" class="footnote" rel="footnote" role="doc-noteref">13</a></sup></ul><p>Besides collections, functions are another example where variance and contravariance matter. Say the following <code class="language-plaintext highlighter-rouge">process</code> function expects a single parameter, which is a function of one argument:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Banana</span> <span class="o">=&gt;</span> <span class="nc">Fruit</span><span class="o">)</span>
</pre></table></code></div></div><p>I can of course pass to <code class="language-plaintext highlighter-rouge">process</code> a function with these exact same types:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">f1</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Banana</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fruit</span> <span class="o">=</span> <span class="n">f</span>
<span class="nf">process</span><span class="o">(</span><span class="n">f1</span><span class="o">)</span>
</pre></table></code></div></div><p>But Scala’s support for subtyping also applies to functions: a function can be a subtype of another function. So I can pass a function with types different from <code class="language-plaintext highlighter-rouge">Banana</code> and <code class="language-plaintext highlighter-rouge">Fruit</code> without breaking expectations as long as the function:</p><ul><li>takes a parameter which is a supertype of <code class="language-plaintext highlighter-rouge">Banana</code><li>returns a value of a subtype of <code class="language-plaintext highlighter-rouge">Fruit</code></ul><p>For example:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">f2</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Apple</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Apple</span>
<span class="nf">process</span><span class="o">(</span><span class="n">f2</span><span class="o">)</span>
</pre></table></code></div></div><p>This is the magic of variance, and you can convince yourself that it makes sense from the point of view of the <code class="language-plaintext highlighter-rouge">process</code> function: expectations won’t be violated.</p><p>Functions are not a special case in Scala from this point of view: a function of one parameter is defined (in a simplified version) as a trait with the function parameter as <em>contravariant</em> and the result as <em>covariant</em>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">To</span> <span class="o">}</span>
</pre></table></code></div></div><h3 id="putting-everything-together">Putting everything together</h3><p>After this detour in variance land, let’s get back to <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> and the implicit parameter. The implicit <code class="language-plaintext highlighter-rouge">&lt;:&lt;[A, A]</code> will conform to the parameter <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code> if it follows the variance rules. So what’s the variance on <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code> in <code class="language-plaintext highlighter-rouge">Predef</code>?</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">&lt;:&lt;[</span><span class="kt">-From</span>, <span class="kt">+To</span><span class="o">]</span>
</pre></table></code></div></div><p>This is the same as <code class="language-plaintext highlighter-rouge">Function1[-From, +To]</code> and in fact <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> extends <code class="language-plaintext highlighter-rouge">Function1</code>! So our problem comes down to the following question: if somebody requires a function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="k">=&gt;</span> <span class="n">U</span>
</pre></table></code></div></div><p>what constraints must be satisfied so I can pass the following function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">A</span>
</pre></table></code></div></div><p>With variance rules, we know it will work if:</p><ul><li><code class="language-plaintext highlighter-rouge">A</code> is supertype of <code class="language-plaintext highlighter-rouge">T</code><li>and <code class="language-plaintext highlighter-rouge">A</code> is subtype of <code class="language-plaintext highlighter-rouge">U</code></ul><p>Written in terms of bounds:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="k">&lt;:</span> <span class="n">A</span> <span class="k">&lt;:</span> <span class="n">U</span>
</pre></table></code></div></div><p>Which means of course that <code class="language-plaintext highlighter-rouge">T &lt;: U</code>: <code class="language-plaintext highlighter-rouge">T</code> must be a subtype of <code class="language-plaintext highlighter-rouge">U</code>!</p><p>To summarize the reasoning: the only eligible implicit definition in scope which can possibly be selected by the compiler to pass to our function is selected if and only if <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>! And that’s exactly what we were looking for! <sup id="fnref:about-conformance"><a href="#fn:about-conformance" class="footnote" rel="footnote" role="doc-noteref">14</a></sup></p><p>You can look at this from a slightly more general angle, which is that a function <code class="language-plaintext highlighter-rouge">A =&gt; A</code> can only be passed to a function <code class="language-plaintext highlighter-rouge">T =&gt; U</code> if <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>. <sup id="fnref:identity"><a href="#fn:identity" class="footnote" rel="footnote" role="doc-noteref">15</a></sup> You can in fact test the matching logic very simply with the built-in <code class="language-plaintext highlighter-rouge">identity</code> function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">Banana</span> <span class="o">=&gt;</span> <span class="nc">Fruit</span>  <span class="k">=</span> <span class="n">identity</span> <span class="c1">// ok</span>
<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">Fruit</span>  <span class="o">=&gt;</span> <span class="nc">Banana</span> <span class="k">=</span> <span class="n">identity</span> <span class="c1">// not ok</span>
</pre></table></code></div></div><p>The same works with <code class="language-plaintext highlighter-rouge">$conforms</code>, which returns an <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, which is also an identity function:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">Banana</span> <span class="o">=&gt;</span> <span class="nc">Fruit</span>  <span class="k">=</span> <span class="nc">$conforms</span> <span class="c1">// ok</span>
<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">Fruit</span>  <span class="o">=&gt;</span> <span class="nc">Banana</span> <span class="k">=</span> <span class="nc">$conforms</span> <span class="c1">// not ok</span>
</pre></table></code></div></div><p>So it is a neat trick that the library authors <sup id="fnref:zaugg"><a href="#fn:zaugg" class="footnote" rel="footnote" role="doc-noteref">16</a></sup> pulled off here, combining implicits and conformance of function types to implement constraint checking.</p><h3 id="the-nitty-gritty">The nitty-gritty</h3><p>The rest of the related code in <code class="language-plaintext highlighter-rouge">Predef</code> is about defining the actual <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> type and creating a singleton instance returned by <code class="language-plaintext highlighter-rouge">def $conforms[A]</code>, because in case the implicit search matches, it must return a real value after all.</p><p>You could write it minimally (using <code class="language-plaintext highlighter-rouge">&lt;::&lt;</code> in these attempts so as to not clash with the standard <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>):</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">&lt;::&lt;</span><span class="o">[</span><span class="kt">-From</span> <span class="k">&lt;:</span> <span class="kt">To</span>, <span class="kt">+To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">To</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="k">new</span> <span class="o">&lt;::&lt;[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{}</span>
</pre></table></code></div></div><p>But oops, the compiler complains:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">T</span>,<span class="kt">U</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="k">trait</span> <span class="nc">&lt;::&lt;</span><span class="ss">'s</span> <span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">-From</span> <span class="k">&lt;:</span> <span class="kt">To</span>,<span class="kt">+To</span><span class="o">]</span>
       <span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></table></code></div></div><p>The good news is that the following version, using an intermediate class, works:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">&lt;::&lt;</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">+To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">$conformance</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">&lt;::&lt;[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">$conformance</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></table></code></div></div><p>So this works great, with a caveat: every time you use my version of <code class="language-plaintext highlighter-rouge">&lt;::&lt;</code>, a new instance of the anonymous class is created. Since we just want an identity function, which works the same for all types and doesn’t hold state, it would be good to use a singleton so as to avoid unnecessary allocations. We could try using an object, since that’s how we do singletons in Scala, but that’s a dead-end because objects cannot take type parameters:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">object</span> <span class="nc">Conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">1</span><span class="k">:</span> <span class="kt">error:</span> <span class="err">'</span><span class="o">;</span><span class="err">'</span> <span class="n">expected</span> <span class="n">but</span> <span class="sc">'['</span> <span class="n">found</span><span class="o">.</span>
<span class="k">implicit</span> <span class="k">object</span> <span class="nc">Conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">}</span>
</pre></table></code></div></div><p>So in the end the standard implementation cheats by creating an untyped singleton using <code class="language-plaintext highlighter-rouge">Any</code>, and casting to <code class="language-plaintext highlighter-rouge">[A &lt;:&lt; A]</code> in the implementation of <code class="language-plaintext highlighter-rouge">$conforms</code>. Here is my attempt, which works fine:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">object</span> <span class="nc">Singleton_&lt;::&lt;</span> <span class="k">extends</span> <span class="o">&lt;::&lt;[</span><span class="kt">Any</span>, <span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="nv">Singleton_&lt;::&lt;</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">:&lt;</span> <span class="kt">A</span><span class="o">]</span>
</pre></table></code></div></div><p>The actual Scala implementation opts for using a <code class="language-plaintext highlighter-rouge">val</code> instead of an <code class="language-plaintext highlighter-rouge">object</code> (maybe to avoid the cost associated with an object’s lazy initialization):</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">val</span> <span class="nv">singleton_&lt;:&lt;</span> <span class="k">=</span> <span class="k">new</span> <span class="o">&lt;:&lt;[</span><span class="kt">Any</span>, <span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">$conforms</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="nv">singleton_&lt;:&lt;</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">A</span><span class="o">]</span>
</pre></table></code></div></div><p>We are only missing one last bit:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nd">@implicitNotFound</span><span class="o">(</span><span class="n">msg</span> <span class="k">=</span> <span class="s">"Cannot prove that ${From} &lt;:&lt; ${To}."</span><span class="o">)</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">&lt;:&lt;</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">+To</span><span class="o">]</span> <span class="err">...</span>
</pre></table></code></div></div><p>This helps provide the user with a nice message when the implicit is not found. From a syntax perspective, it is a regular annotation, which applies to the abstract class <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>. The annotation is known by the compiler. <sup id="fnref:implicit-not-found"><a href="#fn:implicit-not-found" class="footnote" rel="footnote" role="doc-noteref">17</a></sup></p><p>So here we are: the implementation is explained! It’s a bit trickier than it should be in order to prevent extra allocations. I confess that I am a bit disappointed that there doesn’t seem to be a way to avoid an <code class="language-plaintext highlighter-rouge">instanceOf</code>: even though it’s local to the implementation and therefore the lack of safety remains under control, it would be better if it could be avoided.</p><h3 id="an-implicit-conversion">An implicit conversion</h3><p>One thing you might wonder is what to do with the <code class="language-plaintext highlighter-rouge">ev</code> parameter. After all, a value must be passed to the function when the implicit is found (when it’s not found, the compiler blows up so <code class="language-plaintext highlighter-rouge">ev</code> doesn’t need an actual value).</p><p>A first answer is that you don’t absolutely need to use it. It’s there first so the compiler can check the constraint. That’s why it’s commonly called <code class="language-plaintext highlighter-rouge">ev</code>, for “evidence”: its presence stands there as a proof that something (an implicit) exists.</p><p>Nonetheless, <code class="language-plaintext highlighter-rouge">ev</code> must have a value. What is it? It’s the <em>result</em> of the <code class="language-plaintext highlighter-rouge">$conforms[A]</code> function, which is of course of type <code class="language-plaintext highlighter-rouge">&lt;:&lt;[T, U]</code>. And we have seen above that <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> extends <code class="language-plaintext highlighter-rouge">T =&gt; U</code>. So the result of <code class="language-plaintext highlighter-rouge">$conforms[A]</code> is a <em>function</em>, which takes an <code class="language-plaintext highlighter-rouge">A</code> and returns an <code class="language-plaintext highlighter-rouge">A</code>, that is, an identity function. And it not only returns a value of the same type <code class="language-plaintext highlighter-rouge">A</code>, but it actually returns the same value which was passed (that’s the idea of an identity function).</p><p>And you see that in the implementation:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
</pre></table></code></div></div><p>It follows that <code class="language-plaintext highlighter-rouge">ev</code> has for value an identity function from <code class="language-plaintext highlighter-rouge">T</code> to <code class="language-plaintext highlighter-rouge">U</code>: it takes a value <code class="language-plaintext highlighter-rouge">t</code> of type <code class="language-plaintext highlighter-rouge">T</code> and returns that <em>same value</em> but with type <code class="language-plaintext highlighter-rouge">U</code>. This is possible, and makes sense, as we know that <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>, otherwise the implicit wouldn’t have been found.</p><p>But there is more: <code class="language-plaintext highlighter-rouge">ev</code> is also an <em>implicit conversion</em> from <code class="language-plaintext highlighter-rouge">T</code> to <code class="language-plaintext highlighter-rouge">U</code> (from <code class="language-plaintext highlighter-rouge">Banana</code> to <code class="language-plaintext highlighter-rouge">Fruit</code>). How so? Because it has the keyword <code class="language-plaintext highlighter-rouge">implicit</code> in front of it, that’s why!</p><p>To contrast with regular type bounds, if you write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tupleIfSubtype</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">U</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</pre></table></code></div></div><p>the compiler knows that <code class="language-plaintext highlighter-rouge">T</code> is a subtype of <code class="language-plaintext highlighter-rouge">U</code>, thanks of the native semantic of <code class="language-plaintext highlighter-rouge">&lt;:</code>. But with <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, the compiler knows nothing of the sort based on the type parameter section.</p><p>However the presence of the implicit <code class="language-plaintext highlighter-rouge">ev</code> function makes it possible to use the value <code class="language-plaintext highlighter-rouge">t</code> of type <code class="language-plaintext highlighter-rouge">T</code> as a value of type <code class="language-plaintext highlighter-rouge">U</code>. The subtype relationship can be seen as an implicit conversion. This is much safer than using <code class="language-plaintext highlighter-rouge">t.asInstanceOf[U]</code>. You could also be extra-explicit and write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">ev</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</pre></table></code></div></div><p>So you can write:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tToU</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="n">t</span>
</pre></table></code></div></div><p>or:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">tToU</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">T</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="nf">ev</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</pre></table></code></div></div><p>Without the implicit conversion, the compiler complains:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">tToU</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="n">t</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">t.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">T</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">U</span>
       <span class="k">def</span> <span class="nf">tToU</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="n">t</span>
</pre></table></code></div></div><p>You can see how <code class="language-plaintext highlighter-rouge">Option.flatten</code> makes use of the <code class="language-plaintext highlighter-rouge">ev()</code> function:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>def flatten[B](implicit ev: A &lt;:&lt; Option[B]): Option[B] =
  if (isEmpty) None else ev(this.get)
</pre></table></code></div></div><p>In summary, all these features fall together to produce something that makes a lot of sense and is useful.</p><h2 id="question-4-is-there-an-easier-ways-to-achieve-the-same-result">Question 4: Is there an easier ways to achieve the same result?</h2><p>There is at least one other way something like what <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> does can be achieved. The idea is that a method such as <code class="language-plaintext highlighter-rouge">flatten</code> does not need to be included on the base class or trait, in this case <code class="language-plaintext highlighter-rouge">Option</code>. Instead, Scala has, via implicit conversions, what in effect achieves extension methods (AKA the “extend my library” pattern).</p><p>So say that such an extension method is only available on values of type <code class="language-plaintext highlighter-rouge">Option[Option[T]]</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">implicit</span> <span class="k">class</span> <span class="nc">OptionOption</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">oo</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">flattenMe</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">oo</span> <span class="n">flatMap</span> <span class="n">identity</span>
<span class="o">}</span>
</pre></table></code></div></div><p>If we try to apply it to <code class="language-plaintext highlighter-rouge">Some(Some(42))</code>, the method is found and the flattening works:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">)).</span><span class="py">flattenMe</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></table></code></div></div><p>If we try to apply it to <code class="language-plaintext highlighter-rouge">Some(42)</code>, the method is not found and the compiler reports an error:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="py">flattenMe</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">flattenMe</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
       <span class="nc">Some</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="py">flattenMe</span>
</pre></table></code></div></div><p>But I see a few differences with the <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> operator:</p><ul><li>You need to create one implicit class for each type supporting a conversion. In the case of <code class="language-plaintext highlighter-rouge">Option</code>, for example, you need one implicit class taking an <code class="language-plaintext highlighter-rouge">Option[Option[T]</code> to support <code class="language-plaintext highlighter-rouge">flatten</code>, and another implicit class to support <code class="language-plaintext highlighter-rouge">orNull</code>. So this requires a bit more boilerplate than <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> per method.<li>I am not sure whether there something similar to <code class="language-plaintext highlighter-rouge">@implicitNotFound</code> to report a better error in case of problem.</ul><p>So why not do it this way? I think that a good case can be made that it is easier to understand in the case of the relatively simple examples we have seen so far.</p><p><strong>UPDATE 2015-12-10:</strong> Somebody <a href="https://www.reddit.com/r/scala/comments/3tyc8v/deconstructing_a_scala_feature_generalized_type/cxbanat">kindly pointed out</a> that at the time generalized type constraints were implemented, Scala didn’t yet have <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">value classes</a> or <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit classes</a>. Missing value classes meant boxing overhead when running extension methods, while missing implicit classes just meant more boilerplate. So using an implicit value class as I did above was not a great option at the time.</p><p>On the other hand, <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> is a more flexible library feature which you can reuse easily and even combine with other implicits, like in this <a href="http://stackoverflow.com/questions/25149179/how-can-i-use-shapeless-to-create-a-function-abstracting-over-arity">example using Shapeless</a>: <sup id="fnref:unboxed-unions"><a href="#fn:unboxed-unions" class="footnote" rel="footnote" role="doc-noteref">18</a></sup></p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">makeJava</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span>, <span class="kt">L</span>, <span class="kt">S</span>, <span class="kt">R</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">)(</span><span class="k">implicit</span>
  <span class="n">ftp</span><span class="k">:</span> <span class="kt">FnToProduct.Aux</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">L</span> <span class="k">=&gt;</span> <span class="kt">S</span><span class="o">],</span>
  <span class="n">ev</span><span class="k">:</span> <span class="kt">S</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span>
  <span class="n">ffp</span><span class="k">:</span> <span class="kt">FnFromProduct</span><span class="o">[</span><span class="kt">L</span> <span class="k">=&gt;</span> <span class="kt">JList</span><span class="o">[</span><span class="kt">R</span><span class="o">]]</span>
<span class="o">)</span>
</pre></table></code></div></div><p>Finally, when using type bounds, the constraints expressed with <code class="language-plaintext highlighter-rouge">&lt;:</code> and <code class="language-plaintext highlighter-rouge">&gt;:</code> can only apply to the method type parameters (or class type parameters when they are used on a class). This is very useful, as we have seen. But when using <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, you can constrain any two types in scope, and even impose multiple such constraints. Your imagination is the limit:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nc">T</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">C</span>
  <span class="k">type</span> <span class="kt">D</span>

  <span class="k">def</span> <span class="nf">constrainTwoTraitParams</span>         <span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
  <span class="k">def</span> <span class="nf">constrainTraitParamAndTypeMember</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">C</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
  <span class="k">def</span> <span class="nf">constrainTwoTypeMembers</span>         <span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">C</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">D</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
  <span class="k">def</span> <span class="nf">constrainMore</span><span class="o">[</span><span class="kt">Y</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Y</span><span class="o">)</span>          <span class="o">(</span><span class="k">implicit</span> <span class="n">ev1</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">B</span><span class="o">,</span> <span class="n">ev2</span><span class="k">:</span> <span class="kt">Y</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">C</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="k">extends</span> <span class="n">T</span><span class="o">[</span><span class="kt">Banana</span>, <span class="kt">Fruit</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">U</span> <span class="o">=</span> <span class="nc">Fruit</span>
  <span class="k">type</span> <span class="kt">V</span> <span class="o">=</span> <span class="nc">String</span>
<span class="o">}</span>
</pre></table></code></div></div><p>You can even go further and constrain not only these types directly, but higher-order types, as in this (math- and symbol-heavy) <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">example from Miles Sabin</a>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>def size[T](t: T)(implicit ev: (¬¬[T] &lt;:&lt; (Int ∨ String))) = ???
</pre></table></code></div></div><p>In this case, the constraint is not directly on the <code class="language-plaintext highlighter-rouge">T</code> type parameter, but on <code class="language-plaintext highlighter-rouge">¬¬[T]</code>.</p><p>This might be, after all, how the term “generalized type constraint” gets its name.</p><h2 id="perspectives">Perspectives</h2><p>We have seen how regular type bounds:</p><ul><li>behave when using abstract type parameters<li>but don’t work to actually enforce certain useful constraints.</ul><p>We have also seen how we can use instead a generalized type constraint expressed with <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>:</p><ul><li>to implement methods which can only be used when types are aligned in a certain way<li>and how <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> is not a built-in feature of the compiler, but instead a library feature implemented via a smart trick involving implicit search and type conformance.</ul><p>Finally, we have considered:</p><ul><li>how the simple use cases in the standard library could be implemented differently<li>but also how <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> is a more general tool.</ul><p>So is <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> is worth it? Should it be part of the standard library, and should Scala developers learn it?</p><p>I think that the feature suffers from the fact that is is not properly documented, explained, and put in perspective. It also suffers from being a symbolic name with no agreed upon way to pronounce it!</p><p>The standard library uses of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> could be replaced with “extension methods”, which would achieve the same result via Scala features which are easier to understand and familiar to most Scala programmers. I think that this argues against the presence of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> in the standard library, especially at the level of <code class="language-plaintext highlighter-rouge">Predef</code>, and if this was introduced today, my inclination would be to recommend leaving it to third-party libraries such as Shapeless which actually benefit the most from this kind of advanced features.</p><p>On the plus side, when used <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> as a recipe, it is easy to understand and useful, and I can’t help but being impressed that generalized type constraints are implemented at the library level, and that they can emerge from powerful underlying language features such as type inference and implicits.</p><p>This is typical of Scala, and in line with the principle of Martin Odersky that it is better to keep the core language small when possible. So even though the explanation of how <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> works might seem a bit tricky, you can take comfort in thinking that in other languages this might be compiler code, not library code. But I also understand how some programmers <sup id="fnref:true-scala-complexity"><a href="#fn:true-scala-complexity" class="footnote" rel="footnote" role="doc-noteref">19</a></sup> might be bothered by all the machinery behind features like this.</p><p>As for me, I am keeping generalized type constraints in my toolbox, but I like seeing the feature as a gateway to a more in-depth understanding of Scala. I hope this post will help others along this path as well!</p><p><em>Did I get anything wrong? Please let me know!</em></p><div class="footnotes" role="doc-endnotes"><ol><li id="fn:operator-name"><p>Other <a href="http://stackoverflow.com/questions/2603003/operator-in-scala/2603290">suggestions</a> include “Madonna wearing a button-down shirt” and “Angry Donkey”! <a href="#fnref:operator-name" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:operator"><p>It is valid to call this an <em>operator</em>, even though it is not built into the compiler, and is not an operator on values like <code class="language-plaintext highlighter-rouge">+</code>: it is instead an operator on <em>types</em>. In fact the Scala spec calls this <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#infix-types">an infix operator</a>. <a href="#fnref:operator" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:debasishg"><p><a href="https://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html">Using generalized type constraints - How to remove code with Scala 2.8</a>. <a href="#fnref:debasishg" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:name-generalized-type-constraints"><p>I haven’t found a good explanation for the adjective <em>generalized</em>. This makes you think that there are more <em>specific</em> type constraints. But which are those then? <a href="#fnref:name-generalized-type-constraints" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:view-type"><p>It seems that there was another <code class="language-plaintext highlighter-rouge">&lt;%&lt;</code> operator as well, but it’s nowhere to be found in Scala 2.11. I suspect that, since it was related to the concept of <em>view bounds</em>, which are being deprecated, and probably had no use in the Scala standard library, it was removed at some point. <a href="#fnref:view-type" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:subtype-instead-of-exact"><p>The authors of the standard library could have used <code class="language-plaintext highlighter-rouge">=:=</code> to say that the type has to be <em>exactly</em> an <code class="language-plaintext highlighter-rouge">Option[B]</code>, but using the subtyping relationship allows the result of the expression to be a supertype. Assuming <code class="language-plaintext highlighter-rouge">Banana &lt;: Fruit</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Banana</span><span class="o">)).</span><span class="py">flatten</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Fruit</span><span class="o">]</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Fruit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Banana</span><span class="o">())</span>
</pre></table></code></div></div><p><a href="#fnref:subtype-instead-of-exact" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:bounds-naming"><p>“Lower bound” and “upper bound” refer to the type hierarchy: if you draw a type hierarchy with the supertypes at the top and subtypes at the bottom, “lower” means being closer to the bottom, and “upper” means closer to the top. So a “lower bound” for a type means the type cannot be under that. Similarly, an “upper bound” means the type cannot be above that. <a href="#fnref:bounds-naming" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:other-solutions"><p>The compiler could have chosen the solution <code class="language-plaintext highlighter-rouge">Any</code> / <code class="language-plaintext highlighter-rouge">Any</code>, or <code class="language-plaintext highlighter-rouge">AnyRef</code> / <code class="language-plaintext highlighter-rouge">Any</code>. But these would be less useful and the compiler tries to be more specific when it can. <a href="#fnref:other-solutions" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:typelevel-any-inference"><p>The Typelevel team in particular <a href="https://github.com/typelevel/scala/issues/17">wants to address</a> that kind of not-very-useful type inference. <a href="#fnref:typelevel-any-inference" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:implicit-search"><p>That’s how all implicit searches work, see <a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">Where does Scala look for implicits?</a>. <a href="#fnref:implicit-search" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:conforms-shadowing"><p>In a 2014 <a href="https://github.com/scala/scala/commit/4223bc2ddc497457c7dccd1b9b65e98244a9b4d1">commit</a>, the implementation switched to <code class="language-plaintext highlighter-rouge">$conforms</code> instead of <code class="language-plaintext highlighter-rouge">conforms</code> to avoid accidental shadowing. <a href="#fnref:conforms-shadowing" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:implicit-type-parameters-instantiation"><p>It is a bit unusual to see an implicit definition which is parametrized with an an abstract type parameter. Martin Odersky <a href="http://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html#Blog1_cmt-3000550784682205874">commented on this</a> in a blog post: “The new thing in 2.8 is that implicit resolution as a whole has been made more flexible, in that type parameters may now be instantiated by an implicits search. And that improvement made these classes useful.” <a href="#fnref:implicit-type-parameters-instantiation" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:unsafe"><p>Mutable Scala collections and arrays in Scala, in particular, are invariant so you cannot assign a <code class="language-plaintext highlighter-rouge">mutable.ArrayBuffer[Banana]</code> to a <code class="language-plaintext highlighter-rouge">mutable.ArrayBuffer[Fruit]</code>, or an <code class="language-plaintext highlighter-rouge">Array[Banana]</code> to an <code class="language-plaintext highlighter-rouge">Array[Fruit]</code>. <em>Immutable</em> Scala collections are covariant, because it is convenient and safe for them to be. Java arrays are covariant and therefore <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23">unsafe</a>! <a href="#fnref:unsafe" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:about-conformance"><p>The compiler needs to be able to figure out conformance of types outside of implicit search, including every time you pass a parameter to a function. So it’s relatively easy to imagine how the compiler goes through the implicit search path, checking each available implicit, and pondering: “Does this particular implicit have a type which conforms to the required implicit parameter type? If so, I’ll use it, otherwise I’ll continue my search (and fail if the search ends without a match).”. <a href="#fnref:about-conformance" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:identity"><p>In versions of Scala prior to 2.8, the predefined <code class="language-plaintext highlighter-rouge">identity</code> function was defined as <code class="language-plaintext highlighter-rouge">implicit</code>, and you could use it to implement generalized type constraints. However this early implementation had issues related to implicit search, therefore a new solution was implemented in 2.8 and <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> was introduced. But in fact <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code> acts exactly like an implicit identity function under another name! <a href="https://debasishg.blogspot.com/2010/08/using-generalized-type-constraints-how.html#c844646259627614220">James Iry</a> commented on this topic:</p><blockquote><p>BTW, prior to 2.8 the idea could more or less be expressed with</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>def accruedInterest(convention: String)(implicit ev: I =&gt; CouponBond): Int = ...
</pre></table></code></div></div><p>I say more or less because ev could be supplied by any implicit function that converts I to CouponBond. Normally you expect ev be the identity function, but of course somebody could have written an implicit conversion from say DiscountBond to CouponBond which would screw things up royally.</p></blockquote><p><a href="#fnref:identity" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:zaugg"><p>Jason Zaugg <a href="https://gist.github.com/retronym/229163">appears</a> to be the mastermind behind it. <a href="#fnref:zaugg" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:implicit-not-found"><p>Here is a short <a href="http://jsuereth.com/scala/2011/03/15/annotate-your-type-classes.html">blog post</a> on this annotation. <a href="#fnref:implicit-not-found" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:unboxed-unions"><p>For more uses of <code class="language-plaintext highlighter-rouge">&lt;:&lt;</code>, see <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">Unboxed union types in Scala via the Curry-Howard isomorphism</a> by Miles Sabin. <a href="#fnref:unboxed-unions" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:true-scala-complexity"><p>See <a href="http://yz.mit.edu/wp/true-scala-complexity/">Yang Zhang’s post</a>, which made some noise a while back. <a href="#fnref:true-scala-complexity" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Updates</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/vail-resorts-epic-coverage-declined/">Beware of Vail Resorts' Epic Coverage</a><li><a href="/posts/restoring-ibm-memory-typewriter-1/">Restoring an IBM Memory Typewriter - Part 1</a><li><a href="/posts/apple-1-reproduction-part-7-audio-cassette-adapter/">Building an Apple-1 Reproduction in 2024/2025 - Part 7: The Audio Cassette Adapter</a><li><a href="/posts/apple-1-reproduction-part-6-c-programming/">Building an Apple-1 Reproduction in 2024/2025 - Part 6: C Programming</a><li><a href="/posts/apple-1-reproduction-part-3-retro-chip-tester/">Building an Apple-1 Reproduction in 2024 - Part 3: The Retro Chip Tester</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/continuations-in-scala/"><div class="card-body"> <span class="timeago small" > Sep 17, 2011 <i class="unloaded">2011-09-17T16:15:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Continuations in Scala (without a PhD)</h3><div class="text-muted small"><p> With @avernet we have been thinking lately about continuations, for a few reasons: Continuations pop up on the web as a concept that could help with event-based programming Scala has a contin...</p></div></div></a></div><div class="card"> <a href="/posts/scala-partial-functions-without-phd/"><div class="card-body"> <span class="timeago small" > Oct 15, 2011 <i class="unloaded">2011-10-15T12:54:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala partial functions (without a PhD)</h3><div class="text-muted small"><p> If you have done some Scala for a while, you know about pattern matching and match/case. Things like: value match { case Some(value) =&gt; … case None =&gt; … } But there is another use of t...</p></div></div></a></div><div class="card"> <a href="/posts/scala-tip-import-renames/"><div class="card-body"> <span class="timeago small" > Jun 18, 2012 <i class="unloaded">2012-06-18T16:44:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scala tip: import renames</h3><div class="text-muted small"><p> In Java, you often write things like this, which are rather verbose: URLEncoder.encode(...) URLDecoder.decode(...) Since Java 1.5 you can use static imports, but then you are stuck with the orig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/reading-plan-october-checkin/" class="btn btn-outline-primary" prompt="Older"><p>Reading plan: October checkin</p></a> <a href="/posts/scala-on-tessel-2/" class="btn btn-outline-primary" prompt="Newer"><p>Scala on Tessel 2</p></a></div><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script> var disqus_config = function() { this.page.url = 'https://blog.bruchez.name/posts/generalized-type-constraints-in-scala/'; this.page.identifier = '/posts/generalized-type-constraints-in-scala/'; }; (function() { var d = document; var s = d.createElement('script'); s.src = 'https://ebruchez.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="">Erik Bruchez</a>.</p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.bruchez.name{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
